From bcc261c45a60e972b2ef42b6374e64570eb09626 Mon Sep 17 00:00:00 2001
From: VaL Doroshchuk <valentyn.doroshchuk@qt.io>
Date: Wed, 10 Jun 2020 12:47:02 +0200
Subject: [PATCH] WIP Introduce QAVPlayer

* Supports software decoding
* VAAPI hardware decoding for Linux:
  DRM with EGL or
  X11 with GLX
* Video Toolbox for macOS and iOS
* D3D11 for Windows
* MediaCodec for Android.

QT_AVPLAYER_NO_HWDEVICE env var can be used to force using software decoding.

Change-Id: I024f6860c1da59e514735847418fdcae5ae8ece0
---

diff --git a/src/backends/avplayer/avplayer.pro b/src/backends/avplayer/avplayer.pro
new file mode 100644
index 0000000..b87c7f8
--- /dev/null
+++ b/src/backends/avplayer/avplayer.pro
@@ -0,0 +1,83 @@
+TARGET = QtMultimediaAVPlayer
+MODULE = multimediaavplayer
+
+QT = multimedia concurrent multimedia-private
+CONFIG += internal_module
+QT_PRIVATE += gui-private
+
+QMAKE_USE += ffmpeg
+
+PRIVATE_HEADERS += \
+    qavplayerdefs_p.h \
+    qavplayer_p.h \
+    qavcodec_p.h \
+    qavcodec_p_p.h \
+    qavaudiocodec_p.h \
+    qavvideocodec_p.h \
+    qavhwdevice_p.h \
+    qavdemuxer_p.h \
+    qavpacket_p.h \
+    qavframe_p.h \
+    qavframe_p_p.h \
+    qavvideoframe_p.h \
+    qavaudioframe_p.h \
+    qavpacketqueue_p.h \
+    qavplanarvideobuffer_cpu_p.h \
+    qavplanarvideobuffer_gpu_p.h
+
+SOURCES += \
+    qavplayer.cpp \
+    qavcodec.cpp \
+    qavaudiocodec.cpp \
+    qavvideocodec.cpp \
+    qavdemuxer.cpp \
+    qavpacket.cpp \
+    qavframe.cpp \
+    qavvideoframe.cpp \
+    qavaudioframe.cpp \
+    qavplanarvideobuffer_cpu.cpp \
+    qavplanarvideobuffer_gpu.cpp
+
+qtConfig(va_x11):qtConfig(opengl): {
+    QMAKE_USE += va_x11 x11
+    PRIVATE_HEADERS += qavhwdevice_vaapi_x11_glx_p.h
+    SOURCES += qavhwdevice_vaapi_x11_glx.cpp
+}
+
+qtConfig(va_drm):qtConfig(egl): {
+    QMAKE_USE += va_drm egl
+    PRIVATE_HEADERS += qavhwdevice_vaapi_drm_egl_p.h
+    SOURCES += qavhwdevice_vaapi_drm_egl.cpp
+}
+
+macos|darwin {
+    PRIVATE_HEADERS += qavhwdevice_videotoolbox_p.h
+    SOURCES += qavhwdevice_videotoolbox.mm
+    LIBS += -framework CoreVideo -framework Metal -framework CoreMedia -framework QuartzCore -framework IOSurface
+}
+
+win32 {
+    PRIVATE_HEADERS += qavhwdevice_d3d11_p.h
+    SOURCES += qavhwdevice_d3d11.cpp
+}
+
+android {
+    PRIVATE_HEADERS += qavhwdevice_mediacodec_p.h
+    SOURCES += qavhwdevice_mediacodec.cpp
+
+    LIBS += -lavcodec -lavformat -lswscale -lavutil -lswresample
+    equals(ANDROID_TARGET_ARCH, armeabi-v7a): \
+        LIBS += -L$$(AVPLAYER_ANDROID_LIB_ARMEABI_V7A)
+
+    equals(ANDROID_TARGET_ARCH, arm64-v8a): \
+        LIBS += -L$$(AVPLAYER_ANDROID_LIB_ARMEABI_V8A)
+
+    equals(ANDROID_TARGET_ARCH, x86): \
+        LIBS += -L$$(AVPLAYER_ANDROID_LIB_X86)
+
+    equals(ANDROID_TARGET_ARCH, x86_64): \
+        LIBS += -L$$(AVPLAYER_ANDROID_LIB_X86_64)
+}
+
+HEADERS += $$PRIVATE_HEADERS
+load(qt_module)
diff --git a/src/backends/avplayer/qavaudiocodec.cpp b/src/backends/avplayer/qavaudiocodec.cpp
new file mode 100644
index 0000000..753f875
--- /dev/null
+++ b/src/backends/avplayer/qavaudiocodec.cpp
@@ -0,0 +1,86 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavaudiocodec_p.h"
+#include "qavcodec_p_p.h"
+#include <QDebug>
+
+extern "C" {
+#include <libavformat/avformat.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+QAVAudioCodec::QAVAudioCodec(QObject *parent)
+    : QAVCodec(parent)
+{
+}
+
+QAudioFormat QAVAudioCodec::audioFormat() const
+{
+    Q_D(const QAVCodec);
+    QAudioFormat format;
+    if (!d->avctx)
+        return format;
+
+    format.setSampleType(QAudioFormat::Unknown);
+    auto fmt = AVSampleFormat(d->avctx->sample_fmt);
+    if (fmt == AV_SAMPLE_FMT_U8) {
+        format.setSampleSize(8);
+        format.setSampleType(QAudioFormat::UnSignedInt);
+    } else if (fmt == AV_SAMPLE_FMT_S16) {
+        format.setSampleSize(16);
+        format.setSampleType(QAudioFormat::SignedInt);
+    } else if (fmt == AV_SAMPLE_FMT_S32) {
+        format.setSampleSize(32);
+        format.setSampleType(QAudioFormat::SignedInt);
+    } else if (fmt == AV_SAMPLE_FMT_FLT) {
+        format.setSampleSize(32);
+        format.setSampleType(QAudioFormat::Float);
+    }
+
+    format.setCodec(QLatin1String("audio/pcm"));
+    format.setSampleRate(d->avctx->sample_rate);
+    format.setChannelCount(d->avctx->channels);
+    format.setByteOrder(QAudioFormat::LittleEndian);
+
+    return format;
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavaudiocodec_p.h b/src/backends/avplayer/qavaudiocodec_p.h
new file mode 100644
index 0000000..ee786fa
--- /dev/null
+++ b/src/backends/avplayer/qavaudiocodec_p.h
@@ -0,0 +1,72 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVAUDIOCODEC_P_H
+#define QAVAUDIOCODEC_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavcodec_p.h"
+#include "qavaudioframe_p.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAVAudioCodecPrivate;
+class Q_AVPLAYER_EXPORT QAVAudioCodec : public QAVCodec
+{
+public:
+    QAVAudioCodec(QObject *parent = nullptr);
+    QAudioFormat audioFormat() const;
+
+private:
+    Q_DISABLE_COPY(QAVAudioCodec)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavaudioframe.cpp b/src/backends/avplayer/qavaudioframe.cpp
new file mode 100644
index 0000000..96d5846
--- /dev/null
+++ b/src/backends/avplayer/qavaudioframe.cpp
@@ -0,0 +1,170 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavaudioframe_p.h"
+#include "qavframe_p_p.h"
+#include "qavcodec_p.h"
+#include <QDebug>
+
+extern "C" {
+#include "libswresample/swresample.h"
+}
+
+QT_BEGIN_NAMESPACE
+
+class QAVAudioFramePrivate : public QAVFramePrivate
+{
+public:
+    QAudioFormat outAudioFormat;
+    int inSampleRate = 0;
+    SwrContext *swr_ctx = nullptr;
+    uint8_t *audioBuf = nullptr;
+    QByteArray data;
+};
+
+QAVAudioFrame::QAVAudioFrame(QObject *parent)
+    : QAVFrame(*new QAVAudioFramePrivate, parent)
+{
+}
+
+QAVAudioFrame::~QAVAudioFrame()
+{
+    Q_D(QAVAudioFrame);
+    swr_free(&d->swr_ctx);
+    av_freep(&d->audioBuf);
+}
+
+QAVAudioFrame::QAVAudioFrame(const QAVFrame &other, QObject *parent)
+    : QAVAudioFrame(parent)
+{
+    operator=(other);
+}
+
+QAVAudioFrame &QAVAudioFrame::operator=(const QAVFrame &other)
+{
+    Q_D(QAVAudioFrame);
+    QAVFrame::operator=(other);
+    d->data.clear();
+    return *this;
+}
+
+const QAVAudioCodec *QAVAudioFrame::codec() const
+{
+    return reinterpret_cast<const QAVAudioCodec *>(d_func()->codec);
+}
+
+QByteArray QAVAudioFrame::data(const QAudioFormat &format) const
+{
+    auto d = const_cast<QAVAudioFramePrivate *>(reinterpret_cast<QAVAudioFramePrivate *>(d_ptr.data()));
+    auto frame = d->frame;
+    if (!frame)
+        return {};
+
+    if (d->outAudioFormat == format && !d->data.isEmpty())
+        return d->data;
+
+    AVSampleFormat outFormat = AV_SAMPLE_FMT_NONE;
+    int64_t outChannelLayout = av_get_default_channel_layout(format.channelCount());
+    int outSampleRate = format.sampleRate();
+
+    switch (format.sampleSize()) {
+    case 8:
+        outFormat = AV_SAMPLE_FMT_U8;
+        break;
+    case 16:
+        outFormat = AV_SAMPLE_FMT_S16;
+        break;
+    case 32:
+        outFormat = format.sampleType() == QAudioFormat::SignedInt ? AV_SAMPLE_FMT_S32 : AV_SAMPLE_FMT_FLT;
+        break;
+    default:
+        qWarning() << "Could not negotiate output format from" << format;
+        return {};
+    }
+
+    int64_t channelLayout = (frame->channel_layout && frame->channels == av_get_channel_layout_nb_channels(frame->channel_layout))
+        ? frame->channel_layout
+        : av_get_default_channel_layout(frame->channels);
+
+    bool needsConvert = frame->format != outFormat || channelLayout != outChannelLayout || frame->sample_rate != outSampleRate;
+    if (needsConvert && (format != d->outAudioFormat || frame->sample_rate != d->inSampleRate || !d->swr_ctx)) {
+        swr_free(&d->swr_ctx);
+        d->swr_ctx = swr_alloc_set_opts(NULL,
+                                        outChannelLayout, outFormat, outSampleRate,
+                                        channelLayout, AVSampleFormat(frame->format), frame->sample_rate,
+                                        0, NULL);
+        int ret = swr_init(d->swr_ctx);
+        if (!d->swr_ctx || ret < 0) {
+            qWarning() << "Could not init SwrContext" << ret;
+            return {};
+        }
+    }
+
+    if (d->swr_ctx) {
+        const uint8_t **in = (const uint8_t **)frame->extended_data;
+        int outCount = (int64_t)frame->nb_samples * outSampleRate / frame->sample_rate + 256;
+        int outSize = av_samples_get_buffer_size(NULL, format.channelCount(), outCount, outFormat, 0);
+
+        av_freep(&d->audioBuf);
+        uint8_t **out = &d->audioBuf;
+        unsigned bufSize = 0;
+        av_fast_malloc(&d->audioBuf, &bufSize, outSize);
+
+        int samples = swr_convert(d->swr_ctx, out, outCount, in, frame->nb_samples);
+        if (samples < 0) {
+            qWarning() << "Could not convert audio samples";
+            return {};
+        }
+
+        int size = samples * format.channelCount() * av_get_bytes_per_sample(outFormat);
+        d->data = QByteArray::fromRawData((const char *)d->audioBuf, size);
+    } else {
+        int size = av_samples_get_buffer_size(NULL,
+                                              frame->channels,
+                                              frame->nb_samples,
+                                              AVSampleFormat(frame->format), 1);
+        d->data = QByteArray::fromRawData((const char *)frame->data[0], size);
+    }
+
+    d->inSampleRate = frame->sample_rate;
+    d->outAudioFormat = format;
+    return d->data;
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavaudioframe_p.h b/src/backends/avplayer/qavaudioframe_p.h
new file mode 100644
index 0000000..77604e4
--- /dev/null
+++ b/src/backends/avplayer/qavaudioframe_p.h
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVFAUDIORAME_H
+#define QAVFAUDIORAME_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavframe_p.h"
+#include <QAudioFormat>
+
+QT_BEGIN_NAMESPACE
+
+class QAVAudioCodec;
+class QAVAudioFramePrivate;
+class Q_AVPLAYER_EXPORT QAVAudioFrame : public QAVFrame
+{
+public:
+    QAVAudioFrame(QObject *parent = nullptr);
+    ~QAVAudioFrame();
+    QAVAudioFrame(const QAVFrame &other, QObject *parent = nullptr);
+    QAVAudioFrame &operator=(const QAVFrame &other);
+
+    const QAVAudioCodec *codec() const;
+    QByteArray data(const QAudioFormat &format) const;
+
+private:
+    Q_DECLARE_PRIVATE(QAVAudioFrame)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavcodec.cpp b/src/backends/avplayer/qavcodec.cpp
new file mode 100644
index 0000000..cb2f71a
--- /dev/null
+++ b/src/backends/avplayer/qavcodec.cpp
@@ -0,0 +1,145 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavcodec_p.h"
+#include "qavcodec_p_p.h"
+
+#include <QDebug>
+
+extern "C" {
+#include <libavformat/avformat.h>
+#include <libavutil/opt.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+QAVCodec::QAVCodec(QObject *parent)
+    : QAVCodec(*new QAVCodecPrivate, parent)
+{
+}
+
+QAVCodec::QAVCodec(QAVCodecPrivate &d, QObject *parent)
+    : QObject(parent)
+    , d_ptr(&d)
+{
+    d_ptr->avctx = avcodec_alloc_context3(nullptr);
+}
+
+QAVCodec::~QAVCodec()
+{
+    Q_D(QAVCodec);
+    if (d->avctx)
+        avcodec_free_context(&d->avctx);
+}
+
+void QAVCodec::setCodec(AVCodec *c)
+{
+    d_func()->codec = c;
+}
+
+bool QAVCodec::open(AVStream *stream)
+{
+    Q_D(QAVCodec);
+
+    if (!stream)
+        return false;
+
+    int ret = avcodec_parameters_to_context(d->avctx, stream->codecpar);
+    if (ret < 0) {
+        qWarning() << "Failed avcodec_parameters_to_context:" << ret;
+        return false;
+    }
+
+    d->avctx->pkt_timebase = stream->time_base;
+    d->avctx->framerate = stream->avg_frame_rate;
+    if (!d->codec)
+        d->codec = avcodec_find_decoder(d->avctx->codec_id);
+    if (!d->codec) {
+        qWarning() << "No decoder could be found for codec";
+        return false;
+    }
+
+    d->avctx->codec_id = d->codec->id;
+    d->avctx->lowres = d->codec->max_lowres;
+
+    av_opt_set_int(d->avctx, "refcounted_frames", true, 0);
+    av_opt_set_int(d->avctx, "threads", 1, 0);
+    ret = avcodec_open2(d->avctx, d->codec, nullptr);
+    if (ret < 0) {
+        qWarning() << "Could not open the codec:" << d->codec->name << ret;
+        return false;
+    }
+
+    stream->discard = AVDISCARD_DEFAULT;
+    d->stream = stream;
+
+    return true;
+}
+
+AVCodecContext *QAVCodec::avctx() const
+{
+    return d_func()->avctx;
+}
+
+AVCodec *QAVCodec::codec() const
+{
+    return d_func()->codec;
+}
+
+AVStream *QAVCodec::stream() const
+{
+    return d_func()->stream;
+}
+
+QAVFrame QAVCodec::decode(const AVPacket *pkt) const
+{
+    Q_D(const QAVCodec);
+    if (!d->avctx)
+        return {};
+
+    QAVFrame frame(this);
+    int ret = avcodec_send_packet(d->avctx, pkt);
+    if (ret < 0 && ret != AVERROR(EAGAIN))
+        return {};
+
+    avcodec_receive_frame(d->avctx, frame.frame());
+    return frame;
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavcodec_p.h b/src/backends/avplayer/qavcodec_p.h
new file mode 100644
index 0000000..ba726f0
--- /dev/null
+++ b/src/backends/avplayer/qavcodec_p.h
@@ -0,0 +1,89 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVCODEC_P_H
+#define QAVCODEC_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavframe_p.h"
+#include <private/qavplayerdefs_p.h>
+#include <QObject>
+
+QT_BEGIN_NAMESPACE
+
+struct AVStream;
+struct AVPacket;
+struct AVCodec;
+struct AVCodecContext;
+class QAVCodecPrivate;
+class Q_AVPLAYER_EXPORT QAVCodec : public QObject
+{
+public:
+    ~QAVCodec();
+
+    bool open(AVStream *stream);
+    AVCodecContext *avctx() const;
+    void setCodec(AVCodec *c);
+    AVCodec *codec() const;
+    AVStream *stream() const;
+
+    QAVFrame decode(const AVPacket *pkt) const;
+
+protected:
+    QAVCodec(QObject *parent = nullptr);
+    QAVCodec(QAVCodecPrivate &d, QObject *parent = nullptr);
+    QScopedPointer<QAVCodecPrivate> d_ptr;
+    Q_DECLARE_PRIVATE(QAVCodec)
+private:
+    Q_DISABLE_COPY(QAVCodec)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavcodec_p_p.h b/src/backends/avplayer/qavcodec_p_p.h
new file mode 100644
index 0000000..9e6f655
--- /dev/null
+++ b/src/backends/avplayer/qavcodec_p_p.h
@@ -0,0 +1,73 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVCODEC_P_P_H
+#define QAVCODEC_P_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavcodec_p.h"
+
+QT_BEGIN_NAMESPACE
+
+struct AVCodec;
+struct AVStream;
+struct AVCodecContext;
+class QAVCodecPrivate
+{
+public:
+    virtual ~QAVCodecPrivate() = default;
+
+    AVCodecContext *avctx = nullptr;
+    AVCodec *codec = nullptr;
+    AVStream *stream = nullptr;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavdemuxer.cpp b/src/backends/avplayer/qavdemuxer.cpp
new file mode 100644
index 0000000..c5c060b
--- /dev/null
+++ b/src/backends/avplayer/qavdemuxer.cpp
@@ -0,0 +1,408 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavdemuxer_p.h"
+#include "qavvideocodec_p.h"
+#include "qavaudiocodec_p.h"
+#include "qavhwdevice_p.h"
+#include <QtMultimedia/private/qtmultimediaglobal_p.h>
+
+#if QT_CONFIG(va_x11) && QT_CONFIG(opengl)
+#include "qavhwdevice_vaapi_x11_glx_p.h"
+#endif
+
+#if QT_CONFIG(va_drm) && QT_CONFIG(egl)
+#include "qavhwdevice_vaapi_drm_egl_p.h"
+#endif
+
+#if defined(Q_OS_MACOS) || defined(Q_OS_IOS)
+#include "qavhwdevice_videotoolbox_p.h"
+#endif
+
+#if defined(Q_OS_WIN)
+#include "qavhwdevice_d3d11_p.h"
+#endif
+
+#if defined(Q_OS_ANDROID)
+#include "qavhwdevice_mediacodec_p.h"
+#include <QtCore/private/qjnihelpers_p.h>
+extern "C" {
+#include "libavcodec/jni.h"
+}
+#endif
+
+#include <QAtomicInt>
+#include <QDebug>
+
+extern "C" {
+#include <libavformat/avformat.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+class QAVDemuxerPrivate
+{
+    Q_DECLARE_PUBLIC(QAVDemuxer)
+public:
+    QAVDemuxerPrivate(QAVDemuxer *q)
+        : q_ptr(q)
+    {
+    }
+
+    QAVDemuxer *q_ptr = nullptr;
+    AVFormatContext *ctx = nullptr;
+
+    QAtomicInt abortRequest = 0;
+    bool seekable = false;
+    QList<int> audioStreams;
+    QList<int> videoStreams;
+    QList<int> subtitleStreams;
+    int audioStream = -1;
+    int videoStream = -1;
+    int subtitleStream = -1;
+    QScopedPointer<QAVAudioCodec> audioCodec;
+    QScopedPointer<QAVVideoCodec> videoCodec;
+    QScopedPointer<QAVCodec> subtitleCodec;
+
+    AVPacket audioPacket;
+    AVPacket videoPacket;
+    AVPacket subtitlePacket;
+    bool eof = false;
+};
+
+static int decode_interrupt_cb(void *ctx)
+{
+    auto d = reinterpret_cast<QAVDemuxerPrivate *>(ctx);
+    return d ? int(d->abortRequest) : 0;
+}
+
+QAVDemuxer::QAVDemuxer(QObject *parent)
+    : QObject(parent)
+    , d_ptr(new QAVDemuxerPrivate(this))
+{
+#if (LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(58,9,100))
+    static bool loaded = false;
+    if (!loaded) {
+        av_register_all();
+        avcodec_register_all();
+        loaded = true;
+    }
+#endif
+}
+
+QAVDemuxer::~QAVDemuxer()
+{
+    unload();
+}
+
+void QAVDemuxer::abort(bool stop)
+{
+    Q_D(QAVDemuxer);
+    d->abortRequest = stop;
+}
+
+static QAVVideoCodec *create_video_codec(AVStream *stream)
+{
+    QScopedPointer<QAVVideoCodec> codec(new QAVVideoCodec);
+    QScopedPointer<QAVHWDevice> device;
+    AVDictionary *opts = NULL;
+    auto name = QGuiApplication::platformName();
+
+#if QT_CONFIG(va_x11) && QT_CONFIG(opengl)
+    if (name == QLatin1String("xcb")) {
+        device.reset(new QAVHWDevice_VAAPI_X11_GLX);
+        av_dict_set(&opts, "connection_type", "x11", 0);
+    }
+#endif
+#if QT_CONFIG(va_drm) && QT_CONFIG(egl)
+    if (name == QLatin1String("eglfs"))
+        device.reset(new QAVHWDevice_VAAPI_DRM_EGL);
+#endif
+#if defined(Q_OS_MACOS) || defined(Q_OS_IOS)
+    if (name == QLatin1String("cocoa") || name == QLatin1String("ios"))
+        device.reset(new QAVHWDevice_VideoToolbox);
+#endif
+#if defined(Q_OS_WIN)
+    if (name == QLatin1String("windows"))
+        device.reset(new QAVHWDevice_D3D11);
+#endif
+#if defined(Q_OS_ANDROID)
+    if (name == QLatin1String("android")) {
+        device.reset(new QAVHWDevice_MediaCodec);
+        codec->setCodec(avcodec_find_decoder_by_name("h264_mediacodec"));
+        auto vm = QtAndroidPrivate::javaVM();
+        av_jni_set_java_vm(vm, NULL);
+    }
+#endif
+
+    if (!codec->open(stream))
+        return nullptr;
+
+    if (qEnvironmentVariableIsSet("QT_AVPLAYER_NO_HWDEVICE"))
+        return codec.take();
+
+    QList<AVHWDeviceType> supported;
+    for (int i = 0;; ++i) {
+        const AVCodecHWConfig *config = avcodec_get_hw_config(codec->codec(), i);
+        if (!config)
+            break;
+
+        if (config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX)
+            supported.append(config->device_type);
+    }
+
+    qDebug() << codec->codec()->name << ": supported hardware device contexts:";
+    for (auto a: supported)
+        qDebug() << "   " << av_hwdevice_get_type_name(a);
+
+    if (!device) {
+        if (!supported.isEmpty())
+            qWarning() << "None of the hardware accelerations was implemented";
+        return codec.take();
+    }
+
+    AVBufferRef *hw_device_ctx = nullptr;
+    if (av_hwdevice_ctx_create(&hw_device_ctx, device->type(), nullptr, opts, 0) >= 0) {
+        qDebug() << "Using hardware device context:" << av_hwdevice_get_type_name(device->type());
+        codec->avctx()->hw_device_ctx = hw_device_ctx;
+        codec->avctx()->pix_fmt = device->format();
+        codec->setDevice(device.take());
+    }
+
+    return codec.take();
+}
+
+static void log_callback(void *ptr, int level, const char *fmt, va_list vl)
+{
+    if (level > av_log_get_level())
+        return;
+
+    va_list vl2;
+    char line[1024];
+    static int print_prefix = 1;
+
+    va_copy(vl2, vl);
+    av_log_format_line(ptr, level, fmt, vl2, line, sizeof(line), &print_prefix);
+    va_end(vl2);
+
+    qDebug() << "FFmpeg:" << line;
+}
+
+int QAVDemuxer::load(const QUrl &url)
+{
+    Q_D(QAVDemuxer);
+
+    if (!d->ctx)
+        d->ctx = avformat_alloc_context();
+
+    d->ctx->flags |= AVFMT_FLAG_GENPTS;
+    d->ctx->interrupt_callback.callback = decode_interrupt_cb;
+    d->ctx->interrupt_callback.opaque = d;
+
+    QString urlString = url.isLocalFile()
+                      ? QDir::toNativeSeparators(url.toLocalFile())
+                      : url.toString();
+
+    int ret = avformat_open_input(&d->ctx, urlString.toUtf8().constData(), nullptr, nullptr);
+    if (ret < 0)
+        return ret;
+
+    ret = avformat_find_stream_info(d->ctx, NULL);
+    if (ret < 0)
+        return ret;
+
+    for (unsigned int i = 0; i < d->ctx->nb_streams; ++i) {
+        enum AVMediaType type = d->ctx->streams[i]->codecpar->codec_type;
+        if (type == AVMEDIA_TYPE_VIDEO)
+            d->videoStreams.push_back(i);
+        else if (type == AVMEDIA_TYPE_AUDIO)
+            d->audioStreams.push_back(i);
+        else if (type == AVMEDIA_TYPE_SUBTITLE)
+            d->subtitleStreams.push_back(i);
+    }
+
+    d->videoStream = av_find_best_stream(d->ctx, AVMEDIA_TYPE_VIDEO,
+                                         d->videoStream, -1, nullptr, 0);
+    d->audioStream = av_find_best_stream(d->ctx, AVMEDIA_TYPE_AUDIO,
+                                         d->audioStream,
+                                         d->videoStream,
+                                         nullptr, 0);
+    d->subtitleStream = av_find_best_stream(d->ctx, AVMEDIA_TYPE_SUBTITLE,
+                                            d->subtitleStream,
+                                            d->audioStream >= 0 ? d->audioStream : d->videoStream,
+                                            nullptr, 0);
+    if (d->audioStream >= 0) {
+        d->audioCodec.reset(new QAVAudioCodec);
+        if (!d->audioCodec->open(d->ctx->streams[d->audioStream]))
+            qWarning() << "Could not open audio codec";
+    }
+
+    av_log_set_callback(log_callback);
+
+    if (d->videoStream >= 0) {
+        if (!d->videoCodec)
+            d->videoCodec.reset(create_video_codec(d->ctx->streams[d->videoStream]));
+    }
+
+    d->seekable = d->ctx->iformat->read_seek || d->ctx->iformat->read_seek2;
+    if (d->ctx->pb)
+        d->seekable |= bool(d->ctx->pb->seekable);
+
+    return 0;
+}
+
+int QAVDemuxer::videoStream() const
+{
+    return d_func()->videoStream;
+}
+
+void QAVDemuxer::setVideoCodec(QAVVideoCodec *codec)
+{
+    return d_func()->videoCodec.reset(codec);
+}
+
+QAVVideoCodec *QAVDemuxer::videoCodec() const
+{
+    return d_func()->videoCodec.data();
+}
+
+int QAVDemuxer::audioStream() const
+{
+    return d_func()->audioStream;
+}
+
+QAVAudioCodec *QAVDemuxer::audioCodec() const
+{
+    return d_func()->audioCodec.data();
+}
+
+int QAVDemuxer::subtitleStream() const
+{
+    return d_func()->subtitleStream;
+}
+
+void QAVDemuxer::unload()
+{
+    Q_D(QAVDemuxer);
+    if (d->ctx)
+        avformat_close_input(&d->ctx);
+    d->eof = false;
+    d->abortRequest = 0;
+    d->videoStream = -1;
+    d->videoStreams.clear();
+    d->audioStream = -1;
+    d->audioStreams.clear();
+    d->subtitleStream = -1;
+    d->subtitleStreams.clear();
+    d->audioCodec.reset();
+    d->videoCodec.reset();
+    d->subtitleCodec.reset();
+}
+
+bool QAVDemuxer::eof() const
+{
+    Q_D(const QAVDemuxer);
+    return d->eof;
+}
+
+QAVPacket QAVDemuxer::read()
+{
+    Q_D(QAVDemuxer);
+
+    if (!d->ctx || d->eof)
+        return {};
+
+    QAVPacket pkt;
+    int ret = av_read_frame(d->ctx, pkt.packet());
+    if (ret < 0) {
+        if (ret == AVERROR_EOF || avio_feof(d->ctx->pb))
+            d->eof = true;
+
+        return {};
+    }
+
+    if (pkt.packet()->stream_index == d->videoStream)
+        pkt.setCodec(d->videoCodec.data());
+    if (pkt.packet()->stream_index == d->audioStream)
+        pkt.setCodec(d->audioCodec.data());
+    if (pkt.packet()->stream_index == d->subtitleStream)
+        pkt.setCodec(d->subtitleCodec.data());
+
+    return pkt;
+}
+
+bool QAVDemuxer::seekable() const
+{
+    return d_func()->seekable;
+}
+
+int QAVDemuxer::seek(double sec)
+{
+    Q_D(QAVDemuxer);
+    if (!d->ctx || !d->seekable)
+        return -1;
+
+    d->eof = false;
+    int flags = 0;
+    int64_t target = sec * AV_TIME_BASE;
+    int64_t min = target;
+    int64_t max = target;
+    return avformat_seek_file(d->ctx, -1, min, target, max, flags);
+}
+
+double QAVDemuxer::duration() const
+{
+    Q_D(const QAVDemuxer);
+    if (!d->ctx || d->ctx->duration == AV_NOPTS_VALUE)
+        return 0;
+
+    return d->ctx->duration * av_q2d({1, AV_TIME_BASE});
+}
+
+double QAVDemuxer::frameRate() const
+{
+    Q_D(const QAVDemuxer);
+    if (d->videoStream < 0)
+        return 1/24;
+
+    AVRational frame_rate = av_guess_frame_rate(d->ctx, d->ctx->streams[d->videoStream], NULL);
+    return frame_rate.num && frame_rate.den ? av_q2d({frame_rate.den, frame_rate.num}) : 0;
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavdemuxer_p.h b/src/backends/avplayer/qavdemuxer_p.h
new file mode 100644
index 0000000..c52abe5
--- /dev/null
+++ b/src/backends/avplayer/qavdemuxer_p.h
@@ -0,0 +1,98 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVDEMUXER_H
+#define QAVDEMUXER_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavpacket_p.h"
+#include <private/qavplayerdefs_p.h>
+#include <QObject>
+
+QT_BEGIN_NAMESPACE
+
+class QAVDemuxerPrivate;
+class QAVVideoCodec;
+class QAVAudioCodec;
+class Q_AVPLAYER_EXPORT QAVDemuxer : public QObject
+{
+public:
+    QAVDemuxer(QObject *parent = nullptr);
+    ~QAVDemuxer();
+
+    void abort(bool stop = true);
+    int load(const QUrl &url);
+    void unload();
+
+    int videoStream() const;
+    void setVideoCodec(QAVVideoCodec *);
+    QAVVideoCodec *videoCodec() const;
+    int audioStream() const;
+    QAVAudioCodec *audioCodec() const;
+    int subtitleStream() const;
+
+    QAVPacket read();
+
+    double duration() const;
+    bool seekable() const;
+    int seek(double sec);
+    bool eof() const;
+    double frameRate() const;
+
+protected:
+    QScopedPointer<QAVDemuxerPrivate> d_ptr;
+
+private:
+    Q_DISABLE_COPY(QAVDemuxer)
+    Q_DECLARE_PRIVATE(QAVDemuxer)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavframe.cpp b/src/backends/avplayer/qavframe.cpp
new file mode 100644
index 0000000..0016e86
--- /dev/null
+++ b/src/backends/avplayer/qavframe.cpp
@@ -0,0 +1,115 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavframe_p.h"
+#include "qavframe_p_p.h"
+#include "qavcodec_p.h"
+#include <QDebug>
+
+extern "C" {
+#include <libavformat/avformat.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+QAVFrame::QAVFrame(QObject *parent)
+    : QAVFrame(nullptr, parent)
+{
+}
+
+QAVFrame::QAVFrame(const QAVCodec *c, QObject *parent)
+    : QAVFrame(*new QAVFramePrivate, parent)
+{
+    d_ptr->codec = c;
+}
+
+QAVFrame::QAVFrame(const QAVFrame &other)
+    : QAVFrame()
+{
+    *this = other;
+}
+
+QAVFrame::QAVFrame(QAVFramePrivate &d, QObject *parent)
+    : QObject(parent)
+    , d_ptr(&d)
+{
+    d_ptr->frame = av_frame_alloc();
+}
+
+QAVFrame &QAVFrame::operator=(const QAVFrame &other)
+{
+    int64_t pts = d_ptr->frame->pts;
+    av_frame_unref(d_ptr->frame);
+    av_frame_ref(d_ptr->frame, other.d_ptr->frame);
+
+    if (d_ptr->frame->pts < 0)
+        d_ptr->frame->pts = pts;
+
+    d_ptr->codec = other.d_ptr->codec;
+    return *this;
+}
+
+QAVFrame::operator bool() const
+{
+    Q_D(const QAVFrame);
+    return d->codec && d->frame && (d->frame->data[0] || d->frame->data[1] || d->frame->data[2] || d->frame->data[3]);
+}
+
+QAVFrame::~QAVFrame()
+{
+    Q_D(QAVFrame);
+    av_frame_free(&d->frame);
+}
+
+AVFrame *QAVFrame::frame() const
+{
+    Q_D(const QAVFrame);
+    return d->frame;
+}
+
+double QAVFrame::pts() const
+{
+    Q_D(const QAVFrame);
+    if (!d->frame || !d->codec)
+        return -1;
+
+    return d->frame->pts * av_q2d(d->codec->stream()->time_base);
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavframe_p.h b/src/backends/avplayer/qavframe_p.h
new file mode 100644
index 0000000..dfc511e
--- /dev/null
+++ b/src/backends/avplayer/qavframe_p.h
@@ -0,0 +1,83 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVFRAME_H
+#define QAVFRAME_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <QObject>
+#include <private/qavplayerdefs_p.h>
+#include <QVideoFrame>
+
+QT_BEGIN_NAMESPACE
+
+struct AVFrame;
+class QAVFramePrivate;
+class QAVCodec;
+class Q_AVPLAYER_EXPORT QAVFrame : public QObject
+{
+public:
+    QAVFrame(QObject *parent = nullptr);
+    QAVFrame(const QAVCodec *c, QObject *parent = nullptr);
+    ~QAVFrame();
+    QAVFrame(const QAVFrame &other);
+    QAVFrame &operator=(const QAVFrame &other);
+    operator bool() const;
+    AVFrame *frame() const;
+    double pts() const;
+
+protected:
+    QScopedPointer<QAVFramePrivate> d_ptr;
+    QAVFrame(QAVFramePrivate &d, QObject *parent = nullptr);
+    Q_DECLARE_PRIVATE(QAVFrame)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavframe_p_p.h b/src/backends/avplayer/qavframe_p_p.h
new file mode 100644
index 0000000..7a76737
--- /dev/null
+++ b/src/backends/avplayer/qavframe_p_p.h
@@ -0,0 +1,70 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVFAUDIORAME_P_P_H
+#define QAVFAUDIORAME_P_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+QT_BEGIN_NAMESPACE
+
+struct AVFrame;
+class QAVFrame;
+class QAVCodec;
+class QAVFramePrivate
+{
+public:
+    virtual ~QAVFramePrivate() = default;
+
+    const QAVCodec *codec = nullptr;
+    AVFrame *frame = nullptr;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavhwdevice_d3d11.cpp b/src/backends/avplayer/qavhwdevice_d3d11.cpp
new file mode 100644
index 0000000..dc6af25
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_d3d11.cpp
@@ -0,0 +1,77 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavhwdevice_d3d11_p.h"
+#include "qavvideocodec_p.h"
+#include "qavplanarvideobuffer_gpu_p.h"
+#include <QVideoFrame>
+#include <QDebug>
+
+QT_BEGIN_NAMESPACE
+
+QAVHWDevice_D3D11::QAVHWDevice_D3D11(QObject *parent)
+    : QObject(parent)
+{
+}
+
+AVPixelFormat QAVHWDevice_D3D11::format() const
+{
+    return AV_PIX_FMT_D3D11;
+}
+
+AVHWDeviceType QAVHWDevice_D3D11::type() const
+{
+    return AV_HWDEVICE_TYPE_D3D11VA;
+}
+
+bool QAVHWDevice_D3D11::supportsVideoSurface(QAbstractVideoSurface *surface) const
+{
+    if (!surface)
+        return false;
+
+    auto list = surface->supportedPixelFormats(QAbstractVideoBuffer::NoHandle);
+    return list.contains(QVideoFrame::Format_NV12);
+}
+
+QVideoFrame QAVHWDevice_D3D11::decode(const QAVVideoFrame &frame) const
+{
+    return {new QAVPlanarVideoBuffer_GPU(frame), frame.size(), QVideoFrame::Format_NV12};
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavhwdevice_d3d11_p.h b/src/backends/avplayer/qavhwdevice_d3d11_p.h
new file mode 100644
index 0000000..0b76428
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_d3d11_p.h
@@ -0,0 +1,76 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVHWDEVICE_D3D11_P_H
+#define QAVHWDEVICE_D3D11_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavhwdevice_p.h"
+#include <private/qavplayerdefs_p.h>
+
+QT_BEGIN_NAMESPACE
+
+class Q_AVPLAYER_EXPORT QAVHWDevice_D3D11 : public QObject, public QAVHWDevice
+{
+public:
+    QAVHWDevice_D3D11(QObject *parent = nullptr);
+    ~QAVHWDevice_D3D11() = default;
+
+    AVPixelFormat format() const override;
+    AVHWDeviceType type() const override;
+    bool supportsVideoSurface(QAbstractVideoSurface *surface) const override;
+    QVideoFrame decode(const QAVVideoFrame &frame) const override;
+
+private:
+    Q_DISABLE_COPY(QAVHWDevice_D3D11)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavhwdevice_mediacodec.cpp b/src/backends/avplayer/qavhwdevice_mediacodec.cpp
new file mode 100644
index 0000000..5734842
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_mediacodec.cpp
@@ -0,0 +1,81 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavhwdevice_mediacodec_p.h"
+#include "qavvideocodec_p.h"
+#include "qavplanarvideobuffer_gpu_p.h"
+#include <QVideoFrame>
+#include <QDebug>
+
+extern "C" {
+#include <libavutil/pixdesc.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+QAVHWDevice_MediaCodec::QAVHWDevice_MediaCodec(QObject *parent)
+    : QObject(parent)
+{
+}
+
+AVPixelFormat QAVHWDevice_MediaCodec::format() const
+{
+    return AV_PIX_FMT_MEDIACODEC;
+}
+
+AVHWDeviceType QAVHWDevice_MediaCodec::type() const
+{
+    return AV_HWDEVICE_TYPE_MEDIACODEC;
+}
+
+bool QAVHWDevice_MediaCodec::supportsVideoSurface(QAbstractVideoSurface *surface) const
+{
+    if (!surface)
+        return false;
+
+    auto list = surface->supportedPixelFormats(QAbstractVideoBuffer::NoHandle);
+    return list.contains(QVideoFrame::Format_NV12);
+}
+
+QVideoFrame QAVHWDevice_MediaCodec::decode(const QAVVideoFrame &frame) const
+{
+    return {new QAVPlanarVideoBuffer_CPU(frame), frame.size(), QVideoFrame::Format_NV12};
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavhwdevice_mediacodec_p.h b/src/backends/avplayer/qavhwdevice_mediacodec_p.h
new file mode 100644
index 0000000..ddafc3d
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_mediacodec_p.h
@@ -0,0 +1,43 @@
+/*********************************************************
+ * Copyright (C) 2020, Val Doroshchuk <valbok@gmail.com> *
+ *                                                       *
+ * This file is part of QtAVPlayer.                      *
+ * Free Qt Media Player based on FFmpeg.                 *
+ *********************************************************/
+
+#ifndef QAVHWDEVICE_MEDIACODEC_P_H
+#define QAVHWDEVICE_MEDIACODEC_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavhwdevice_p.h"
+
+QT_BEGIN_NAMESPACE
+
+class Q_AVPLAYER_EXPORT QAVHWDevice_MediaCodec : public QObject, public QAVHWDevice
+{
+public:
+    QAVHWDevice_MediaCodec(QObject *parent = nullptr);
+    ~QAVHWDevice_MediaCodec() = default;
+
+    AVPixelFormat format() const override;
+    AVHWDeviceType type() const override;
+    bool supportsVideoSurface(QAbstractVideoSurface *surface) const override;
+    QVideoFrame decode(const QAVVideoFrame &frame) const override;
+
+private:
+    Q_DISABLE_COPY(QAVHWDevice_MediaCodec)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavhwdevice_p.h b/src/backends/avplayer/qavhwdevice_p.h
new file mode 100644
index 0000000..e289e46
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_p.h
@@ -0,0 +1,83 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVHWDEVICE_P_H
+#define QAVHWDEVICE_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <private/qavplayerdefs_p.h>
+#include <QVideoFrame>
+
+extern "C" {
+#include <libavformat/avformat.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+class QAVVideoFrame;
+class QAVCodec;
+class QAbstractVideoSurface;
+class Q_AVPLAYER_EXPORT QAVHWDevice
+{
+public:
+    QAVHWDevice() = default;
+    virtual ~QAVHWDevice() = default;
+
+    virtual AVPixelFormat format() const = 0;
+    virtual AVHWDeviceType type() const = 0;
+    virtual bool supportsVideoSurface(QAbstractVideoSurface *surface) const = 0;
+    virtual QVideoFrame decode(const QAVVideoFrame &frame) const = 0;
+
+private:
+    Q_DISABLE_COPY(QAVHWDevice)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavhwdevice_vaapi_drm_egl.cpp b/src/backends/avplayer/qavhwdevice_vaapi_drm_egl.cpp
new file mode 100644
index 0000000..7eda5c3
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_vaapi_drm_egl.cpp
@@ -0,0 +1,197 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavhwdevice_vaapi_drm_egl_p.h"
+#include "qavvideocodec_p.h"
+#include "qavplanarvideobuffer_gpu_p.h"
+#include <QVideoFrame>
+#include <QDebug>
+
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+#include <va/va_drmcommon.h>
+#include <drm/drm_fourcc.h>
+
+extern "C" {
+#include <libavutil/hwcontext_vaapi.h>
+}
+
+static PFNEGLCREATEIMAGEKHRPROC s_eglCreateImageKHR = nullptr;
+static PFNEGLDESTROYIMAGEKHRPROC s_eglDestroyImageKHR = nullptr;
+static PFNGLEGLIMAGETARGETTEXTURE2DOESPROC s_glEGLImageTargetTexture2DOES = nullptr;
+
+QT_BEGIN_NAMESPACE
+
+class QAVHWDevice_VAAPI_DRM_EGLPrivate
+{
+public:
+    GLuint textures[2] = {0};
+};
+
+QAVHWDevice_VAAPI_DRM_EGL::QAVHWDevice_VAAPI_DRM_EGL(QObject *parent)
+    : QObject(parent)
+    , d_ptr(new QAVHWDevice_VAAPI_DRM_EGLPrivate)
+{
+}
+
+QAVHWDevice_VAAPI_DRM_EGL::~QAVHWDevice_VAAPI_DRM_EGL()
+{
+    Q_D(QAVHWDevice_VAAPI_DRM_EGL);
+
+    glDeleteTextures(2, d->textures);
+}
+
+AVPixelFormat QAVHWDevice_VAAPI_DRM_EGL::format() const
+{
+    return AV_PIX_FMT_VAAPI;
+}
+
+AVHWDeviceType QAVHWDevice_VAAPI_DRM_EGL::type() const
+{
+    return AV_HWDEVICE_TYPE_VAAPI;
+}
+
+bool QAVHWDevice_VAAPI_DRM_EGL::supportsVideoSurface(QAbstractVideoSurface *surface) const
+{
+    if (!surface)
+        return false;
+
+    auto list = surface->supportedPixelFormats(QAbstractVideoBuffer::GLTextureHandle);
+    return list.contains(QVideoFrame::Format_NV12);
+}
+
+class VideoBuffer_EGL : public QAVPlanarVideoBuffer_GPU
+{
+public:
+    VideoBuffer_EGL(QAVHWDevice_VAAPI_DRM_EGLPrivate *hw, const QAVVideoFrame &frame)
+        : QAVPlanarVideoBuffer_GPU(frame, GLTextureHandle)
+        , m_hw(hw)
+    {
+        if (!s_eglCreateImageKHR) {
+            s_eglCreateImageKHR = reinterpret_cast<PFNEGLCREATEIMAGEKHRPROC>(eglGetProcAddress("eglCreateImageKHR"));
+            s_eglDestroyImageKHR = reinterpret_cast<PFNEGLDESTROYIMAGEKHRPROC>(eglGetProcAddress("eglDestroyImageKHR"));
+            s_glEGLImageTargetTexture2DOES = reinterpret_cast<PFNGLEGLIMAGETARGETTEXTURE2DOESPROC>(eglGetProcAddress("glEGLImageTargetTexture2DOES"));
+        }
+    }
+
+    QVariant textures() const
+    {
+        return QList<QVariant>() << m_hw->textures[0] << m_hw->textures[1];
+    }
+
+    QVariant handle() const override
+    {
+        if (!m_hw->textures[0])
+            glGenTextures(2, m_hw->textures);
+
+        auto va_frame = frame().frame();
+        AVHWDeviceContext *hwctx = (AVHWDeviceContext *)frame().codec()->avctx()->hw_device_ctx->data;
+        AVVAAPIDeviceContext *vactx = (AVVAAPIDeviceContext *)hwctx->hwctx;
+        VADisplay va_display = vactx->display;
+        VASurfaceID va_surface = (VASurfaceID)(uintptr_t)va_frame->data[3];
+
+        VADRMPRIMESurfaceDescriptor prime;
+        auto status = vaExportSurfaceHandle(va_display, va_surface,
+                                            VA_SURFACE_ATTRIB_MEM_TYPE_DRM_PRIME_2,
+                                            VA_EXPORT_SURFACE_READ_ONLY | VA_EXPORT_SURFACE_SEPARATE_LAYERS,
+                                            &prime);
+        if (status != VA_STATUS_SUCCESS) {
+            qWarning() << "vaExportSurfaceHandle failed" << status;
+            return textures();
+        }
+
+        if (prime.fourcc != VA_FOURCC_NV12) {
+            qWarning() << "prime.fourcc != VA_FOURCC_NV12";
+            return textures();
+        }
+
+        vaSyncSurface(va_display, va_surface);
+
+        static const uint32_t formats[2] = { DRM_FORMAT_R8, DRM_FORMAT_GR88 };
+        for (int i = 0; i < 2; ++i) {
+            if (prime.layers[i].drm_format != formats[i])
+                qWarning() << "Wrong DRM format:" << prime.layers[i].drm_format << formats[i];
+
+            EGLint img_attr[] = {
+                EGL_LINUX_DRM_FOURCC_EXT,      EGLint(formats[i]),
+                EGL_WIDTH,                     va_frame->width / (i + 1),
+                EGL_HEIGHT,                    va_frame->height / (i + 1),
+                EGL_DMA_BUF_PLANE0_FD_EXT,     prime.objects[prime.layers[i].object_index[0]].fd,
+                EGL_DMA_BUF_PLANE0_OFFSET_EXT, EGLint(prime.layers[i].offset[0]),
+                EGL_DMA_BUF_PLANE0_PITCH_EXT,  EGLint(prime.layers[i].pitch[0]),
+                EGL_NONE
+            };
+
+            EGLImage img = s_eglCreateImageKHR(eglGetCurrentDisplay(),
+                                               EGL_NO_CONTEXT,
+                                               EGL_LINUX_DMA_BUF_EXT,
+                                               NULL, img_attr);
+            if (!img) {
+                qWarning() << "eglCreateImageKHR failed";
+                return textures();
+            }
+
+            glActiveTexture(GL_TEXTURE0 + i);
+            glBindTexture(GL_TEXTURE_2D, m_hw->textures[i]);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+            s_glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, img);
+            if (glGetError())
+                qWarning() << "glEGLImageTargetTexture2DOES failed";
+
+            glBindTexture(GL_TEXTURE_2D, 0);
+            s_eglDestroyImageKHR(eglGetCurrentDisplay(), img);
+        }
+
+        return textures();
+    }
+
+    QAVHWDevice_VAAPI_DRM_EGLPrivate *m_hw = nullptr;
+};
+
+QVideoFrame QAVHWDevice_VAAPI_DRM_EGL::decode(const QAVVideoFrame &frame) const
+{
+    return {new VideoBuffer_EGL(d_ptr.data(), frame), frame.size(), QVideoFrame::Format_NV12};
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavhwdevice_vaapi_drm_egl_p.h b/src/backends/avplayer/qavhwdevice_vaapi_drm_egl_p.h
new file mode 100644
index 0000000..ced68eb
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_vaapi_drm_egl_p.h
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVHWDEVICE_VAAPI_DRM_EGL_P_H
+#define QAVHWDEVICE_VAAPI_DRM_EGL_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavhwdevice_p.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAVHWDevice_VAAPI_DRM_EGLPrivate;
+class Q_AVPLAYER_EXPORT QAVHWDevice_VAAPI_DRM_EGL : public QObject, public QAVHWDevice
+{
+public:
+    QAVHWDevice_VAAPI_DRM_EGL(QObject *parent = nullptr);
+    ~QAVHWDevice_VAAPI_DRM_EGL();
+
+    AVPixelFormat format() const override;
+    AVHWDeviceType type() const override;
+    bool supportsVideoSurface(QAbstractVideoSurface *surface) const override;
+    QVideoFrame decode(const QAVVideoFrame &frame) const override;
+
+private:
+    QScopedPointer<QAVHWDevice_VAAPI_DRM_EGLPrivate> d_ptr;
+    Q_DISABLE_COPY(QAVHWDevice_VAAPI_DRM_EGL)
+    Q_DECLARE_PRIVATE(QAVHWDevice_VAAPI_DRM_EGL)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavhwdevice_vaapi_x11_glx.cpp b/src/backends/avplayer/qavhwdevice_vaapi_x11_glx.cpp
new file mode 100644
index 0000000..3a9acc4
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_vaapi_x11_glx.cpp
@@ -0,0 +1,215 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavhwdevice_vaapi_x11_glx_p.h"
+#include "qavvideocodec_p.h"
+#include "qavplanarvideobuffer_gpu_p.h"
+#include <QVideoFrame>
+#include <QDebug>
+
+#include <GL/glx.h>
+#include <va/va_x11.h>
+
+extern "C" {
+#include <libavutil/hwcontext_vaapi.h>
+}
+
+typedef void (*glXBindTexImageEXT_)(Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
+typedef void (*glXReleaseTexImageEXT_)(Display *dpy, GLXDrawable draw, int buffer);
+static glXBindTexImageEXT_ s_glXBindTexImageEXT = nullptr;
+static glXReleaseTexImageEXT_ s_glXReleaseTexImageEXT = nullptr;
+
+QT_BEGIN_NAMESPACE
+
+class QAVHWDevice_VAAPI_X11_GLXPrivate
+{
+public:
+    Pixmap pixmap = 0;
+    GLXPixmap glxpixmap = 0;
+    Display *display = nullptr;
+    GLuint texture = 0;
+};
+
+QAVHWDevice_VAAPI_X11_GLX::QAVHWDevice_VAAPI_X11_GLX(QObject *parent)
+    : QObject(parent)
+    , d_ptr(new QAVHWDevice_VAAPI_X11_GLXPrivate)
+{
+}
+
+QAVHWDevice_VAAPI_X11_GLX::~QAVHWDevice_VAAPI_X11_GLX()
+{
+    Q_D(QAVHWDevice_VAAPI_X11_GLX);
+
+    if (d->glxpixmap) {
+        s_glXReleaseTexImageEXT(d->display, d->glxpixmap, GLX_FRONT_EXT);
+        glXDestroyPixmap(d->display, d->glxpixmap);
+    }
+    if (d->pixmap)
+        XFreePixmap(d->display, d->pixmap);
+
+    glDeleteTextures(1, &d->texture);
+}
+
+AVPixelFormat QAVHWDevice_VAAPI_X11_GLX::format() const
+{
+    return AV_PIX_FMT_VAAPI;
+}
+
+AVHWDeviceType QAVHWDevice_VAAPI_X11_GLX::type() const
+{
+    return AV_HWDEVICE_TYPE_VAAPI;
+}
+
+bool QAVHWDevice_VAAPI_X11_GLX::supportsVideoSurface(QAbstractVideoSurface *surface) const
+{
+    if (!surface)
+        return false;
+
+    auto list = surface->supportedPixelFormats(QAbstractVideoBuffer::GLTextureHandle);
+    return list.contains(QVideoFrame::Format_ABGR32);
+}
+
+class VideoBuffer_GLX : public QAVPlanarVideoBuffer_GPU
+{
+public:
+    VideoBuffer_GLX(QAVHWDevice_VAAPI_X11_GLXPrivate *hw, const QAVVideoFrame &frame)
+        : QAVPlanarVideoBuffer_GPU(frame, GLTextureHandle)
+        , m_hw(hw)
+    {
+        if (!s_glXBindTexImageEXT) {
+            s_glXBindTexImageEXT = (glXBindTexImageEXT_) glXGetProcAddressARB((const GLubyte *)"glXBindTexImageEXT");
+            s_glXReleaseTexImageEXT = (glXReleaseTexImageEXT_) glXGetProcAddressARB((const GLubyte *)"glXReleaseTexImageEXT");
+        }
+    }
+
+    QVariant handle() const override
+    {
+        if (!s_glXBindTexImageEXT) {
+            qWarning() << "Could not get proc address: s_glXBindTexImageEXT";
+            return 0;
+        }
+
+        auto av_frame = frame().frame();
+        AVHWDeviceContext *hwctx = (AVHWDeviceContext *)frame().codec()->avctx()->hw_device_ctx->data;
+        AVVAAPIDeviceContext *vactx = (AVVAAPIDeviceContext *)hwctx->hwctx;
+        VADisplay va_display = vactx->display;
+        VASurfaceID va_surface = (VASurfaceID)(uintptr_t)av_frame->data[3];
+
+        int w = av_frame->width;
+        int h = av_frame->height;
+
+        if (!m_hw->display) {
+            glGenTextures(1, &m_hw->texture);
+            auto display = (Display *)glXGetCurrentDisplay();
+            m_hw->display = display;
+            int xscr = DefaultScreen(display);
+            const char *glxext = glXQueryExtensionsString(display, xscr);
+            if (!glxext || !strstr(glxext, "GLX_EXT_texture_from_pixmap")) {
+                qWarning() << "GLX_EXT_texture_from_pixmap is not supported";
+                return 0;
+            }
+
+            int attribs[] = {
+                GLX_RENDER_TYPE, GLX_RGBA_BIT,
+                GLX_X_RENDERABLE, True,
+                GLX_BIND_TO_TEXTURE_RGBA_EXT, True,
+                GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
+                GLX_BIND_TO_TEXTURE_TARGETS_EXT, GLX_TEXTURE_2D_BIT_EXT,
+                GLX_Y_INVERTED_EXT, True,
+                GLX_DOUBLEBUFFER, False,
+                GLX_RED_SIZE, 8,
+                GLX_GREEN_SIZE, 8,
+                GLX_BLUE_SIZE, 8,
+                GLX_ALPHA_SIZE, 8,
+                None
+            };
+
+            int fbcount;
+            GLXFBConfig *fbcs = glXChooseFBConfig(display, xscr, attribs, &fbcount);
+            if (!fbcount) {
+                XFree(fbcs);
+                qWarning() << "No texture-from-pixmap support";
+                return 0;
+            }
+
+            GLXFBConfig fbc = fbcs[0];
+            XFree(fbcs);
+
+            XWindowAttributes xwa;
+            XGetWindowAttributes(display, DefaultRootWindow(display), &xwa);
+
+            m_hw->pixmap = XCreatePixmap(display, DefaultRootWindow(display), w, h, xwa.depth);
+
+            const int attribs_pixmap[] = {
+                GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,
+                GLX_TEXTURE_FORMAT_EXT, xwa.depth == 32 ? GLX_TEXTURE_FORMAT_RGBA_EXT : GLX_TEXTURE_FORMAT_RGB_EXT,
+                GLX_MIPMAP_TEXTURE_EXT, False,
+                None,
+            };
+
+            m_hw->glxpixmap = glXCreatePixmap(display, fbc, m_hw->pixmap, attribs_pixmap);
+        }
+
+        vaSyncSurface(va_display, va_surface);
+        auto status = vaPutSurface(va_display, va_surface, m_hw->pixmap,
+                                   0, 0, w, h,
+                                   0, 0, w, h,
+                                   NULL, 0, VA_FRAME_PICTURE | VA_SRC_BT709);
+        if (status != VA_STATUS_SUCCESS) {
+            qWarning() << "vaPutSurface failed" << status;
+            return 0;
+        }
+
+        XSync(m_hw->display, False);
+        glBindTexture(GL_TEXTURE_2D, m_hw->texture);
+        s_glXBindTexImageEXT(m_hw->display, m_hw->glxpixmap, GLX_FRONT_EXT, NULL);
+        glBindTexture(GL_TEXTURE_2D, 0);
+
+        return m_hw->texture;
+    }
+
+    QAVHWDevice_VAAPI_X11_GLXPrivate *m_hw = nullptr;
+};
+
+QVideoFrame QAVHWDevice_VAAPI_X11_GLX::decode(const QAVVideoFrame &frame) const
+{
+    return {new VideoBuffer_GLX(d_ptr.data(), frame), frame.size(), QVideoFrame::Format_ABGR32};
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavhwdevice_vaapi_x11_glx_p.h b/src/backends/avplayer/qavhwdevice_vaapi_x11_glx_p.h
new file mode 100644
index 0000000..687da5e
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_vaapi_x11_glx_p.h
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVHWDEVICE_VAAPI_X11_GLX_P_H
+#define QAVHWDEVICE_VAAPI_X11_GLX_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavhwdevice_p.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAVHWDevice_VAAPI_X11_GLXPrivate;
+class Q_AVPLAYER_EXPORT QAVHWDevice_VAAPI_X11_GLX : public QObject, public QAVHWDevice
+{
+public:
+    QAVHWDevice_VAAPI_X11_GLX(QObject *parent = nullptr);
+    ~QAVHWDevice_VAAPI_X11_GLX();
+
+    AVPixelFormat format() const override;
+    AVHWDeviceType type() const override;
+    bool supportsVideoSurface(QAbstractVideoSurface *surface) const override;
+    QVideoFrame decode(const QAVVideoFrame &frame) const override;
+
+private:
+    QScopedPointer<QAVHWDevice_VAAPI_X11_GLXPrivate> d_ptr;
+    Q_DISABLE_COPY(QAVHWDevice_VAAPI_X11_GLX)
+    Q_DECLARE_PRIVATE(QAVHWDevice_VAAPI_X11_GLX)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavhwdevice_videotoolbox.mm b/src/backends/avplayer/qavhwdevice_videotoolbox.mm
new file mode 100644
index 0000000..0d558ad
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_videotoolbox.mm
@@ -0,0 +1,148 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavhwdevice_videotoolbox_p.h"
+#include "qavvideocodec_p.h"
+#include "qavplanarvideobuffer_gpu_p.h"
+#include <QVideoFrame>
+#include <QDebug>
+
+#import <CoreVideo/CoreVideo.h>
+#if defined(Q_OS_MACOS)
+#import <IOSurface/IOSurface.h>
+#else
+#import <IOSurface/IOSurfaceRef.h>
+#endif
+#import <Metal/Metal.h>
+
+QT_BEGIN_NAMESPACE
+
+class QAVHWDevice_VideoToolboxPrivate
+{
+public:
+    id<MTLDevice> device = nullptr;
+    CVPixelBufferRef pbuf = nullptr;
+};
+
+QAVHWDevice_VideoToolbox::QAVHWDevice_VideoToolbox(QObject *parent)
+    : QObject(parent)
+    , d_ptr(new QAVHWDevice_VideoToolboxPrivate)
+{
+}
+
+QAVHWDevice_VideoToolbox::~QAVHWDevice_VideoToolbox()
+{
+    Q_D(QAVHWDevice_VideoToolbox);
+    CVPixelBufferRelease(d->pbuf);
+    [d->device release];
+}
+
+AVPixelFormat QAVHWDevice_VideoToolbox::format() const
+{
+    return AV_PIX_FMT_VIDEOTOOLBOX;
+}
+
+AVHWDeviceType QAVHWDevice_VideoToolbox::type() const
+{
+    return AV_HWDEVICE_TYPE_VIDEOTOOLBOX;
+}
+
+bool QAVHWDevice_VideoToolbox::supportsVideoSurface(QAbstractVideoSurface *surface) const
+{
+    if (!surface)
+        return false;
+
+    auto list = surface->supportedPixelFormats(QAbstractVideoBuffer::MTLTextureHandle);
+    return list.contains(QVideoFrame::Format_NV12);
+}
+
+class VideoBuffer_MTL : public QAVPlanarVideoBuffer_GPU
+{
+public:
+    VideoBuffer_MTL(QAVHWDevice_VideoToolboxPrivate *hw, const QAVVideoFrame &frame)
+        : QAVPlanarVideoBuffer_GPU(frame, MTLTextureHandle)
+        , m_hw(hw)
+    {
+    }
+
+    QVariant handle() const override
+    {
+        CVPixelBufferRelease(m_hw->pbuf);
+        m_hw->pbuf = (CVPixelBufferRef)frame().frame()->data[3];
+        CVPixelBufferRetain(m_hw->pbuf);
+        QList<QVariant> textures(2);
+
+        if (!m_hw->pbuf)
+            return textures;
+
+        if (CVPixelBufferGetDataSize(m_hw->pbuf) <= 0)
+            return textures;
+
+        auto format = CVPixelBufferGetPixelFormatType(m_hw->pbuf);
+        if (format != '420v') {
+            qWarning() << "420v is supported only";
+            return textures;
+        }
+
+        if (!m_hw->device)
+            m_hw->device = MTLCreateSystemDefaultDevice();
+
+        IOSurfaceRef surface = CVPixelBufferGetIOSurface(m_hw->pbuf);
+        int planes = CVPixelBufferGetPlaneCount(m_hw->pbuf);
+        for (int i = 0; i < planes; ++i) {
+            int w = IOSurfaceGetWidthOfPlane(surface, i);
+            int h = IOSurfaceGetHeightOfPlane(surface, i) ;
+            MTLPixelFormat f = i ?  MTLPixelFormatRG8Unorm : MTLPixelFormatR8Unorm;
+            MTLTextureDescriptor *desc = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:f width:w height:h mipmapped:NO];
+
+            textures[i] = quint64([m_hw->device newTextureWithDescriptor:desc iosurface:surface plane:i]);
+        }
+
+        return textures;
+    }
+
+    QAVHWDevice_VideoToolboxPrivate *m_hw = nullptr;
+};
+
+QVideoFrame QAVHWDevice_VideoToolbox::decode(const QAVVideoFrame &frame) const
+{
+    return {new VideoBuffer_MTL(d_ptr.data(), frame), frame.size(), QVideoFrame::Format_NV12};
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavhwdevice_videotoolbox_p.h b/src/backends/avplayer/qavhwdevice_videotoolbox_p.h
new file mode 100644
index 0000000..aa6cc49
--- /dev/null
+++ b/src/backends/avplayer/qavhwdevice_videotoolbox_p.h
@@ -0,0 +1,78 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVHWDEVICE_VIDEOTOOLBOX_P_H
+#define QAVHWDEVICE_VIDEOTOOLBOX_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavhwdevice_p.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAVHWDevice_VideoToolboxPrivate;
+class Q_AVPLAYER_EXPORT QAVHWDevice_VideoToolbox : public QObject, public QAVHWDevice
+{
+public:
+    QAVHWDevice_VideoToolbox(QObject *parent = nullptr);
+    ~QAVHWDevice_VideoToolbox();
+
+    AVPixelFormat format() const override;
+    AVHWDeviceType type() const override;
+    bool supportsVideoSurface(QAbstractVideoSurface *surface) const override;
+    QVideoFrame decode(const QAVVideoFrame &frame) const override;
+
+private:
+    QScopedPointer<QAVHWDevice_VideoToolboxPrivate> d_ptr;
+    Q_DISABLE_COPY(QAVHWDevice_VideoToolbox)
+    Q_DECLARE_PRIVATE(QAVHWDevice_VideoToolbox)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavpacket.cpp b/src/backends/avplayer/qavpacket.cpp
new file mode 100644
index 0000000..9c8a86f
--- /dev/null
+++ b/src/backends/avplayer/qavpacket.cpp
@@ -0,0 +1,139 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavpacket_p.h"
+#include "qavcodec_p.h"
+#include <QDebug>
+
+extern "C" {
+#include <libavcodec/avcodec.h>
+#include <libavformat/avformat.h>
+#include <libavutil/opt.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+class QAVPacketPrivate
+{
+public:
+    const QAVCodec *codec = nullptr;
+    AVPacket pkt;
+    QAVFrame frame;
+};
+
+QAVPacket::QAVPacket(QObject *parent)
+    : QObject(parent)
+    , d_ptr(new QAVPacketPrivate)
+{
+    av_init_packet(&d_ptr->pkt);
+    d_ptr->pkt.size = 0;
+    d_ptr->pkt.stream_index = -1;
+}
+
+QAVPacket::QAVPacket(const QAVPacket &other)
+    : QAVPacket()
+{
+    *this = other;
+}
+
+QAVPacket &QAVPacket::operator=(const QAVPacket &other)
+{
+    av_packet_unref(&d_ptr->pkt);
+    av_packet_ref(&d_ptr->pkt, &other.d_ptr->pkt);
+    d_ptr->codec = other.d_ptr->codec;
+    d_ptr->frame = other.d_ptr->frame;
+    return *this;
+}
+
+QAVPacket::operator bool() const
+{
+    Q_D(const QAVPacket);
+    return d->pkt.size;
+}
+
+QAVPacket::~QAVPacket()
+{
+    Q_D(QAVPacket);
+    av_packet_unref(&d->pkt);
+}
+
+AVPacket *QAVPacket::packet()
+{
+    return &d_func()->pkt;
+}
+
+double QAVPacket::duration() const
+{
+    Q_D(const QAVPacket);
+    if (!d->codec || !d->codec->stream())
+        return 0;
+
+    return d->pkt.duration * av_q2d(d->codec->stream()->time_base);
+}
+
+int QAVPacket::bytes() const
+{
+    return d_func()->pkt.size;
+}
+
+int QAVPacket::streamIndex() const
+{
+    return d_func()->pkt.stream_index;
+}
+
+void QAVPacket::setCodec(const QAVCodec *c)
+{
+    Q_D(QAVPacket);
+    d->codec = c;
+}
+
+QAVFrame QAVPacket::decode()
+{
+    Q_D(QAVPacket);
+    if (!d->codec)
+        return {};
+
+    if (d->frame)
+        return d->frame;
+
+    d->frame = d->codec->decode(&d->pkt);
+    return d->frame;
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavpacket_p.h b/src/backends/avplayer/qavpacket_p.h
new file mode 100644
index 0000000..687f788
--- /dev/null
+++ b/src/backends/avplayer/qavpacket_p.h
@@ -0,0 +1,88 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVPACKET_H
+#define QAVPACKET_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavframe_p.h"
+#include <QObject>
+
+QT_BEGIN_NAMESPACE
+
+struct AVPacket;
+class QAVPacketPrivate;
+class QAVCodec;
+class Q_AVPLAYER_EXPORT QAVPacket : public QObject
+{
+public:
+    QAVPacket(QObject *parent = nullptr);
+    ~QAVPacket();
+    QAVPacket(const QAVPacket &other);
+    QAVPacket &operator=(const QAVPacket &other);
+    operator bool() const;
+
+    AVPacket *packet();
+    double duration() const;
+    int bytes() const;
+    int streamIndex() const;
+
+    void setCodec(const QAVCodec *codec);
+    QAVFrame decode();
+
+protected:
+    QScopedPointer<QAVPacketPrivate> d_ptr;
+
+private:
+    Q_DECLARE_PRIVATE(QAVPacket)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavpacketqueue_p.h b/src/backends/avplayer/qavpacketqueue_p.h
new file mode 100644
index 0000000..adc9b06
--- /dev/null
+++ b/src/backends/avplayer/qavpacketqueue_p.h
@@ -0,0 +1,234 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVPACKETQUEUE_H
+#define QAVPACKETQUEUE_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavpacket_p.h"
+#include <QMutex>
+#include <QList>
+
+extern "C" {
+#include <libavutil/time.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+class QAVQueueClock
+{
+public:
+    QAVQueueClock(double v = 1/24)
+        : frameRate(v)
+    {
+    }
+
+    bool sync(double pts, double speed = 1.0, double master = -1)
+    {
+        double delay = pts - prevPts;
+        if (isnan(delay) || delay <= 0 || delay > maxFrameDuration)
+            delay = frameRate;
+
+        if (master > 0) {
+            double diff = pts - master;
+            double sync_threshold = qMax(minThreshold, qMin(maxThreshold, delay));
+            if (!isnan(diff) && fabs(diff) < maxFrameDuration) {
+                if (diff <= -sync_threshold)
+                    delay = qMax(0.0, delay + diff);
+                else if (diff >= sync_threshold && delay > frameDuplicationThreshold)
+                    delay = delay + diff;
+                else if (diff >= sync_threshold)
+                    delay = 2 * delay;
+            }
+        }
+
+        delay /= speed;
+        double time = av_gettime_relative() / 1000000.0;
+        if (time < frameTimer + delay) {
+            double remaining_time = qMin(frameTimer + delay - time, refreshRate);
+            av_usleep((int64_t)(remaining_time * 1000000.0));
+            return false;
+        }
+
+        prevPts = pts;
+        frameTimer += delay;
+        if (delay > 0 && time - frameTimer > maxThreshold)
+            frameTimer = time;
+
+        return true;
+    }
+
+    double frameRate = 0;
+    double frameTimer = 0;
+    double prevPts = 0;
+    const double maxFrameDuration = 10.0;
+    const double minThreshold = 0.04;
+    const double maxThreshold = 0.1;
+    const double frameDuplicationThreshold = 0.1;
+    const double refreshRate = 0.01;
+};
+
+class QAVPacketQueue
+{
+public:
+    QAVPacketQueue() = default;
+    ~QAVPacketQueue()
+    {
+        m_waiter.wakeAll();
+    }
+
+    bool isEmpty() const
+    {
+        QMutexLocker locker(&m_mutex);
+        return m_packets.isEmpty();
+    }
+
+    void enqueue(const QAVPacket &packet)
+    {
+        QMutexLocker lock(&m_mutex);
+        m_packets.append(packet);
+        m_bytes += packet.bytes() + sizeof(packet);
+        m_duration += packet.duration();
+        m_waiter.wakeAll();
+    }
+
+    QAVPacket dequeue()
+    {
+        QMutexLocker locker(&m_mutex);
+        if (m_packets.isEmpty())
+            m_waiter.wait(&m_mutex, 100);
+        if (m_packets.isEmpty())
+            return {};
+        auto packet = m_packets.takeFirst();
+        m_bytes -= packet.bytes() + sizeof(packet);
+        m_duration -= packet.duration();
+        return packet;
+    }
+
+    void pop()
+    {
+        QMutexLocker locker(&m_mutex);
+        m_frame = QAVFrame();
+    }
+
+    void wakeAll()
+    {
+        m_waiter.wakeAll();
+    }
+
+    bool enough() const
+    {
+        QMutexLocker locker(&m_mutex);
+        const int minFrames = 15;
+        return m_packets.size() > minFrames && (!m_duration || m_duration > 1.0);
+    }
+
+    int bytes() const
+    {
+        QMutexLocker locker(&m_mutex);
+        return m_bytes;
+    }
+
+    void clear()
+    {
+        QMutexLocker locker(&m_mutex);
+        m_packets.clear();
+        m_bytes = 0;
+        m_duration = 0;
+
+        m_clock.prevPts = 0;
+        m_clock.frameTimer = 0;
+        m_frame = QAVFrame();
+    }
+
+    QAVFrame sync(double speed = 1.0, double master = -1)
+    {
+        QMutexLocker locker(&m_mutex);
+        auto frame = m_frame;
+        if (!frame) {
+            locker.unlock();
+            frame = dequeue().decode();
+            locker.relock();
+            m_frame = frame;
+        }
+        locker.unlock();
+
+        if (!frame || !m_clock.sync(frame.pts(), speed, master))
+            return {};
+
+        return frame;
+    }
+
+    double pts() const
+    {
+        QMutexLocker locker(&m_mutex);
+        return m_clock.prevPts;
+    }
+
+    void setFrameRate(double v)
+    {
+        QMutexLocker locker(&m_mutex);
+        m_clock.frameRate = v;
+    }
+
+private:
+    QList<QAVPacket> m_packets;
+    mutable QMutex m_mutex;
+    QWaitCondition m_waiter;
+
+    int m_bytes = 0;
+    int m_duration = 0;
+
+    QAVFrame m_frame;
+    QAVQueueClock m_clock;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavplanarvideobuffer_cpu.cpp b/src/backends/avplayer/qavplanarvideobuffer_cpu.cpp
new file mode 100644
index 0000000..9d340bd
--- /dev/null
+++ b/src/backends/avplayer/qavplanarvideobuffer_cpu.cpp
@@ -0,0 +1,94 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavplanarvideobuffer_cpu_p.h"
+#include "qavvideoframe_p.h"
+#include <QVideoFrame>
+#include <QDebug>
+
+extern "C" {
+#include <libavutil/imgutils.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+QAVPlanarVideoBuffer_CPU::QAVPlanarVideoBuffer_CPU(HandleType type)
+    : QAbstractPlanarVideoBuffer(type)
+{
+}
+
+QAVPlanarVideoBuffer_CPU::QAVPlanarVideoBuffer_CPU(const QAVVideoFrame &frame, HandleType type)
+    : QAbstractPlanarVideoBuffer(type)
+    , m_frame(frame)
+{
+}
+
+QAbstractVideoBuffer::MapMode QAVPlanarVideoBuffer_CPU::mapMode() const
+{
+    return m_mode;
+}
+
+int QAVPlanarVideoBuffer_CPU::map(MapMode mode, int *numBytes, int bytesPerLine[4], uchar *data[4])
+{
+    auto frame = m_frame.frame();
+    if (m_mode != NotMapped || !frame || mode == NotMapped)
+        return 0;
+
+    m_mode = mode;
+    if (numBytes)
+        *numBytes = av_image_get_buffer_size(AVPixelFormat(frame->format), frame->width, frame->height, 1);
+
+    int i = 0;
+    for (; i < 4; ++i) {
+        if (!frame->linesize[i])
+            break;
+
+        bytesPerLine[i] = frame->linesize[i];
+        data[i] = static_cast<uchar *>(frame->data[i]);
+    }
+
+    return i;
+}
+
+void QAVPlanarVideoBuffer_CPU::unmap()
+{
+    m_mode = NotMapped;
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavplanarvideobuffer_cpu_p.h b/src/backends/avplayer/qavplanarvideobuffer_cpu_p.h
new file mode 100644
index 0000000..dee46cf
--- /dev/null
+++ b/src/backends/avplayer/qavplanarvideobuffer_cpu_p.h
@@ -0,0 +1,79 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVPLANARVIDEOBUFFER_CPU_P_H
+#define QAVPLANARVIDEOBUFFER_CPU_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavvideoframe_p.h"
+#include <private/qavplayerdefs_p.h>
+#include <QAbstractPlanarVideoBuffer>
+
+QT_BEGIN_NAMESPACE
+
+class Q_AVPLAYER_EXPORT QAVPlanarVideoBuffer_CPU : public QAbstractPlanarVideoBuffer
+{
+public:
+    QAVPlanarVideoBuffer_CPU(HandleType type = NoHandle);
+    QAVPlanarVideoBuffer_CPU(const QAVVideoFrame &frame, HandleType type = NoHandle);
+
+    MapMode mapMode() const override;
+    int map(MapMode mode, int *numBytes, int bytesPerLine[4], uchar *data[4]) override;
+    void unmap() override;
+
+    const QAVVideoFrame &frame() const { return m_frame; }
+
+private:
+    QAVVideoFrame m_frame;
+    MapMode m_mode = NotMapped;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavplanarvideobuffer_gpu.cpp b/src/backends/avplayer/qavplanarvideobuffer_gpu.cpp
new file mode 100644
index 0000000..d88490c
--- /dev/null
+++ b/src/backends/avplayer/qavplanarvideobuffer_gpu.cpp
@@ -0,0 +1,72 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavplanarvideobuffer_gpu_p.h"
+#include "qavvideoframe_p.h"
+#include <QDebug>
+
+QT_BEGIN_NAMESPACE
+
+QAVPlanarVideoBuffer_GPU::QAVPlanarVideoBuffer_GPU(const QAVVideoFrame &frame, HandleType type)
+    : QAbstractPlanarVideoBuffer(type)
+    , m_frame(frame)
+{
+}
+
+QAbstractVideoBuffer::MapMode QAVPlanarVideoBuffer_GPU::mapMode() const
+{
+    return m_cpu.mapMode();
+}
+
+int QAVPlanarVideoBuffer_GPU::map(MapMode mode, int *numBytes, int bytesPerLine[4], uchar *data[4])
+{
+    int ret = av_hwframe_transfer_data(m_cpu.frame().frame(), m_frame.frame(), 0);
+    if (ret < 0)
+        return 0;
+
+    m_frame = QAVVideoFrame();
+    return m_cpu.map(mode, numBytes, bytesPerLine, data);
+}
+
+void QAVPlanarVideoBuffer_GPU::unmap()
+{
+    m_cpu.unmap();
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavplanarvideobuffer_gpu_p.h b/src/backends/avplayer/qavplanarvideobuffer_gpu_p.h
new file mode 100644
index 0000000..f27ba12
--- /dev/null
+++ b/src/backends/avplayer/qavplanarvideobuffer_gpu_p.h
@@ -0,0 +1,76 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVPLANARVIDEOBUFFER_GPU_P_H
+#define QAVPLANARVIDEOBUFFER_GPU_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavplanarvideobuffer_cpu_p.h"
+
+QT_BEGIN_NAMESPACE
+
+class Q_AVPLAYER_EXPORT QAVPlanarVideoBuffer_GPU : public QAbstractPlanarVideoBuffer
+{
+public:
+    QAVPlanarVideoBuffer_GPU(const QAVVideoFrame &frame, HandleType type = NoHandle);
+
+    MapMode mapMode() const override;
+    int map(MapMode mode, int *numBytes, int bytesPerLine[4], uchar *data[4]) override;
+    void unmap() override;
+
+    const QAVVideoFrame &frame() const { return m_frame; }
+
+private:
+    QAVVideoFrame m_frame;
+    QAVPlanarVideoBuffer_CPU m_cpu;
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavplayer.cpp b/src/backends/avplayer/qavplayer.cpp
new file mode 100644
index 0000000..319db06
--- /dev/null
+++ b/src/backends/avplayer/qavplayer.cpp
@@ -0,0 +1,607 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavplayer_p.h"
+#include "qavdemuxer_p.h"
+#include "qavvideocodec_p.h"
+#include "qavaudiocodec_p.h"
+#include "qavvideoframe_p.h"
+#include "qavaudioframe_p.h"
+#include "qavpacketqueue_p.h"
+
+#include <QAbstractVideoSurface>
+#include <qtconcurrentrun.h>
+
+QT_BEGIN_NAMESPACE
+
+class QAVPlayerPrivate
+{
+    Q_DECLARE_PUBLIC(QAVPlayer)
+public:
+    QAVPlayerPrivate(QAVPlayer *q)
+        : q_ptr(q)
+    {
+    }
+
+    void setMediaStatus(QMediaPlayer::MediaStatus status);
+    void setState(QMediaPlayer::State s);
+    void setSeekable(bool seekable);
+    void setError(QMediaPlayer::Error err, const QString &str);
+    void setDuration(double d);
+    void updatePosition(double p);
+
+    bool isAudioAvailable() const;
+    bool isVideoAvailable() const;
+    void terminate();
+    void doWait();
+    void doEndOfMedia();
+
+    void doLoad(const QUrl &url);
+    void doDemux();
+    void doPlayVideo();
+    void doFlushVideo();
+    void doPlayAudio();
+
+    template <class T>
+    void call(T fn);
+
+    QAVPlayer *q_ptr = nullptr;
+    QUrl url;
+    QAbstractVideoSurface *surface = nullptr;
+    QMediaPlayer::MediaStatus mediaStatus = QMediaPlayer::NoMedia;
+    QMediaPlayer::State state = QMediaPlayer::StoppedState;
+    bool seekable = false;
+    int volume = 100;
+    bool muted = false;
+    qreal speed = 1.0;
+
+    QMediaPlayer::Error error = QMediaPlayer::NoError;
+    QString errorString;
+
+    double duration = 0;
+    double position = 0;
+    double pendingPosition = -1;
+    bool pendingPlay = false;
+
+    QAVDemuxer demuxer;
+
+    QFuture<void> loaderFuture;
+    QFuture<void> demuxerFuture;
+
+    QFuture<void> videoPlayFuture;
+    QAVPacketQueue videoQueue;
+
+    QFuture<void> audioPlayFuture;
+    QAVPacketQueue audioQueue;
+    double audioPts = 0;
+
+    QScopedPointer<QAudioOutput> audioOutput;
+
+    bool quit = 0;
+    bool wait = false;
+    QMutex waitMutex;
+    QWaitCondition waitCond;
+    mutable QMutex positionMutex;
+};
+
+static QString err_str(int err)
+{
+    char errbuf[128];
+    const char *errbuf_ptr = errbuf;
+    if (av_strerror(err, errbuf, sizeof(errbuf)) < 0)
+        errbuf_ptr = strerror(AVUNERROR(err));
+
+    return QString::fromUtf8(errbuf_ptr);
+}
+
+void QAVPlayerPrivate::setMediaStatus(QMediaPlayer::MediaStatus status)
+{
+    Q_Q(QAVPlayer);
+    if (mediaStatus == status)
+        return;
+
+    mediaStatus = status;
+    emit q->mediaStatusChanged(status);
+    if (pendingPlay && status == QMediaPlayer::LoadedMedia)
+        q->play();
+}
+
+void QAVPlayerPrivate::setState(QMediaPlayer::State s)
+{
+    Q_Q(QAVPlayer);
+    if (state == s)
+        return;
+
+    state = s;
+    emit q->stateChanged(s);
+}
+
+void QAVPlayerPrivate::setSeekable(bool s)
+{
+    Q_Q(QAVPlayer);
+    if (seekable == s)
+        return;
+
+    seekable = s;
+    emit q->seekableChanged(seekable);
+}
+
+void QAVPlayerPrivate::setDuration(double d)
+{
+    Q_Q(QAVPlayer);
+    if (qFuzzyCompare(duration, d))
+        return;
+
+    duration = d;
+    emit q->durationChanged(q->duration());
+}
+
+void QAVPlayerPrivate::updatePosition(double p)
+{
+    QMutexLocker lock(&positionMutex);
+    position = p;
+}
+
+template <class T>
+void QAVPlayerPrivate::call(T fn)
+{
+    QMetaObject::invokeMethod(q_ptr, fn, nullptr);
+}
+
+void QAVPlayerPrivate::setError(QMediaPlayer::Error err, const QString &str)
+{
+    Q_Q(QAVPlayer);
+    if (error == err)
+        return;
+
+    qWarning() << "Error:" << url << ":"<< str;
+    error = err;
+    errorString = str;
+    emit q->errorOccurred(err, str);
+    setMediaStatus(QMediaPlayer::InvalidMedia);
+}
+
+bool QAVPlayerPrivate::isAudioAvailable() const
+{
+    return demuxer.audioStream() >= 0;
+}
+
+bool QAVPlayerPrivate::isVideoAvailable() const
+{
+    return demuxer.videoStream() >= 0;
+}
+
+void QAVPlayerPrivate::terminate()
+{
+    setState(QMediaPlayer::StoppedState);
+    demuxer.abort();
+    quit = true;
+    pendingPlay = false;
+    wait = false;
+    waitCond.wakeAll();
+    videoQueue.clear();
+    videoQueue.wakeAll();
+    audioQueue.clear();
+    audioQueue.wakeAll();
+    loaderFuture.waitForFinished();
+    demuxerFuture.waitForFinished();
+    videoPlayFuture.waitForFinished();
+    audioPlayFuture.waitForFinished();
+}
+
+void QAVPlayerPrivate::doWait()
+{
+    QMutexLocker lock(&waitMutex);
+    if (wait)
+        waitCond.wait(&waitMutex, 5000);
+}
+
+void QAVPlayerPrivate::doFlushVideo()
+{
+    call([this] { if (surface) surface->present({}); });
+}
+
+void QAVPlayerPrivate::doLoad(const QUrl &url)
+{
+    demuxer.abort(false);
+    demuxer.unload();
+    int ret = demuxer.load(url);
+    if (ret < 0) {
+        call([this, ret] { setError(QMediaPlayer::ResourceError, err_str(ret)); });
+        return;
+    }
+
+    if (demuxer.videoStream() < 0 && demuxer.audioStream() < 0) {
+        call([this] { setError(QMediaPlayer::ResourceError, QLatin1String("No codecs found")); });
+        return;
+    }
+
+    // Negotiate pixel formats here.
+    if (demuxer.videoCodec())
+        demuxer.videoCodec()->setVideoSurface(surface);
+
+    double d = demuxer.duration();
+    bool seekable = demuxer.seekable();
+    call([this, seekable, d] {
+        setSeekable(seekable);
+        setDuration(d);
+        setMediaStatus(QMediaPlayer::LoadedMedia);
+    });
+
+    demuxerFuture = QtConcurrent::run(&QAVPlayerPrivate::doDemux, this);
+    videoPlayFuture = QtConcurrent::run(&QAVPlayerPrivate::doPlayVideo, this);
+    audioPlayFuture = QtConcurrent::run(&QAVPlayerPrivate::doPlayAudio, this);
+}
+
+void QAVPlayerPrivate::doDemux()
+{
+    const int maxQueueBytes = 15 * 1024 * 1024;
+    QMutex mutex;
+    QWaitCondition waiter;
+
+    while (!quit) {
+        doWait();
+        if (videoQueue.bytes() + audioQueue.bytes() > maxQueueBytes
+            || (videoQueue.enough() && audioQueue.enough()))
+        {
+            QMutexLocker locker(&mutex);
+            waiter.wait(&mutex, 10);
+            continue;
+        }
+
+        positionMutex.lock();
+        if (pendingPosition >= 0) {
+            int ret = demuxer.seek(pendingPosition);
+            if (ret >= 0) {
+                videoQueue.clear();
+                audioQueue.clear();
+            } else {
+                qWarning() << "Could not seek:" << err_str(ret);
+            }
+            pendingPosition = -1;
+        }
+        positionMutex.unlock();
+
+        auto packet = demuxer.read();
+        if (!packet) {
+            if (demuxer.eof() && videoQueue.isEmpty() && audioQueue.isEmpty())
+                doEndOfMedia();
+
+            QMutexLocker locker(&mutex);
+            waiter.wait(&mutex, 10);
+            continue;
+        }
+
+        if (packet.streamIndex() == demuxer.videoStream())
+            videoQueue.enqueue(packet);
+        else if (packet.streamIndex() == demuxer.audioStream())
+            audioQueue.enqueue(packet);
+    }
+}
+
+void QAVPlayerPrivate::doEndOfMedia()
+{
+    Q_Q(QAVPlayer);
+    doFlushVideo();
+    call([this, q] {
+        q->stop();
+        setMediaStatus(QMediaPlayer::EndOfMedia);
+    });
+}
+
+void QAVPlayerPrivate::doPlayVideo()
+{
+    videoQueue.setFrameRate(demuxer.frameRate());
+
+    while (!quit) {
+        doWait();
+        QAVVideoFrame frame = videoQueue.sync(speed, audioQueue.pts());
+        if (!frame)
+            continue;
+
+        QVideoFrame videoFrame = frame;
+        call([this, videoFrame] {
+            if (!surface)
+                return;
+            if (!surface->isActive())
+                surface->start({videoFrame.size(), videoFrame.pixelFormat(), videoFrame.handleType()});
+            if (surface->isActive())
+                surface->present(videoFrame);
+        });
+
+        videoQueue.pop();
+        updatePosition(frame.pts());
+    }
+
+    doFlushVideo();
+    videoQueue.clear();
+}
+
+void QAVPlayerPrivate::doPlayAudio()
+{
+    QAVAudioFrame frame;
+    QIODevice *device = nullptr;
+    QAudioFormat format;
+
+    while (!quit) {
+        doWait();
+        frame = audioQueue.sync(speed);
+        if (!frame)
+            continue;
+
+        if (!format.isValid()) {
+            format = frame.codec()->audioFormat();
+            if (format.sampleType() != QAudioFormat::SignedInt) {
+                format.setSampleSize(16);
+                format.setSampleType(QAudioFormat::SignedInt);
+            }
+
+            audioOutput.reset(new QAudioOutput(format));
+            if (!device)
+                device = audioOutput->start();
+        }
+
+        if (!muted) {
+            audioOutput->setVolume(volume / 100.0);
+            int pos = 0;
+            frame.frame()->sample_rate *= speed;
+            auto data = frame.data(format);
+            int size = data.size();
+            while (size && !quit) {
+                if (audioOutput->bytesFree() < audioOutput->periodSize()) {
+                    const double refreshRate = 0.01;
+                    av_usleep((int64_t)(refreshRate * 1000000.0));
+                    continue;
+                }
+
+                int chunk = qMin(size, audioOutput->periodSize());
+                QByteArray decodedChunk = QByteArray::fromRawData(data.constData() + pos, chunk);
+                int wrote = device->write(decodedChunk);
+                if (wrote > 0) {
+                    pos += chunk;
+                    size -= chunk;
+                }
+            }
+        }
+
+        audioQueue.pop();
+        if (!isVideoAvailable())
+            updatePosition(frame.pts());
+    }
+
+    audioOutput.reset();
+    audioQueue.clear();
+}
+
+QAVPlayer::QAVPlayer(QObject *parent)
+    : QObject(parent)
+    , d_ptr(new QAVPlayerPrivate(this))
+{
+}
+
+QAVPlayer::~QAVPlayer()
+{
+    Q_D(QAVPlayer);
+    d->terminate();
+}
+
+void QAVPlayer::setSource(const QUrl &url)
+{
+    Q_D(QAVPlayer);
+    if (d->url == url)
+        return;
+
+    d->terminate();
+    d->url = url;
+    emit sourceChanged(url);
+    if (d->url.isEmpty()) {
+        d->setMediaStatus(QMediaPlayer::NoMedia);
+        d->setDuration(0);
+        d->updatePosition(0);
+        return;
+    }
+
+    d->quit = false;
+    d->setMediaStatus(QMediaPlayer::LoadingMedia);
+    d->loaderFuture = QtConcurrent::run(&QAVPlayerPrivate::doLoad, d, d->url);
+    QMutexLocker locker(&d->waitMutex);
+    d->wait = true;
+}
+
+QUrl QAVPlayer::source() const
+{
+    return d_func()->url;
+}
+
+bool QAVPlayer::isAudioAvailable() const
+{
+    return d_func()->isAudioAvailable();
+}
+
+bool QAVPlayer::isVideoAvailable() const
+{
+    return d_func()->isVideoAvailable();
+}
+
+void QAVPlayer::setVideoSurface(QAbstractVideoSurface *surface)
+{
+    d_func()->surface = surface;
+}
+
+QMediaPlayer::State QAVPlayer::state() const
+{
+    return d_func()->state;
+}
+
+QMediaPlayer::MediaStatus QAVPlayer::mediaStatus() const
+{
+    return d_func()->mediaStatus;
+}
+
+void QAVPlayer::play()
+{
+    Q_D(QAVPlayer);
+    if (d->url.isEmpty() || d->mediaStatus == QMediaPlayer::InvalidMedia)
+        return;
+
+    d->setState(QMediaPlayer::PlayingState);
+    if (d->mediaStatus == QMediaPlayer::EndOfMedia) {
+        QMutexLocker locker(&d->positionMutex);
+        if (d->pendingPosition < 0) {
+            locker.unlock();
+            seek(0);
+        }
+        d->setMediaStatus(QMediaPlayer::LoadedMedia);
+    } else if (d->mediaStatus != QMediaPlayer::LoadedMedia) {
+        d->pendingPlay = true;
+        return;
+    }
+
+    QMutexLocker locker(&d->waitMutex);
+    if (!d->wait)
+        return;
+
+    d->wait = false;
+    d->waitCond.wakeAll();
+    d->pendingPlay = false;
+}
+
+void QAVPlayer::pause()
+{
+    Q_D(QAVPlayer);
+    d->setState(QMediaPlayer::PausedState);
+    QMutexLocker locker(&d->waitMutex);
+    d->wait = true;
+}
+
+void QAVPlayer::stop()
+{
+    Q_D(QAVPlayer);
+    d->setState(QMediaPlayer::StoppedState);
+    QMutexLocker locker(&d->waitMutex);
+    d->wait = true;
+}
+
+bool QAVPlayer::isSeekable() const
+{
+    return d_func()->seekable;
+}
+
+void QAVPlayer::seek(qint64 pos)
+{
+    Q_D(QAVPlayer);
+    if (pos < 0 || (duration() > 0 && pos > duration()))
+        return;
+
+    QMutexLocker lock(&d->positionMutex);
+    d->pendingPosition = pos / 1000.0;
+}
+
+qint64 QAVPlayer::duration() const
+{
+    return d_func()->duration * 1000;
+}
+
+qint64 QAVPlayer::position() const
+{
+    Q_D(const QAVPlayer);
+    QMutexLocker lock(&d->positionMutex);
+    if (d->pendingPosition >= 0)
+        return d->pendingPosition * 1000;
+    if (d->mediaStatus == QMediaPlayer::EndOfMedia)
+        return duration();
+    return d->position * 1000;
+}
+
+void QAVPlayer::setVolume(int volume)
+{
+    Q_D(QAVPlayer);
+    if (d->volume == volume || volume < 0 || volume > 100)
+        return;
+
+    d->volume = volume;
+    emit volumeChanged(volume);
+}
+
+int QAVPlayer::volume() const
+{
+    return d_func()->volume;
+}
+
+void QAVPlayer::setMuted(bool m)
+{
+    Q_D(QAVPlayer);
+    if (d->muted == m)
+        return;
+
+    d->muted = m;
+    emit mutedChanged(m);
+}
+
+bool QAVPlayer::isMuted() const
+{
+    return d_func()->muted;
+}
+
+void QAVPlayer::setSpeed(qreal r)
+{
+    Q_D(QAVPlayer);
+    if (qFuzzyCompare(d->speed, r))
+        return;
+
+    d->speed = r;
+    emit speedChanged(r);
+}
+
+qreal QAVPlayer::speed() const
+{
+    return d_func()->speed;
+}
+
+QMediaPlayer::Error QAVPlayer::error() const
+{
+    return d_func()->error;
+}
+
+QString QAVPlayer::errorString() const
+{
+    return d_func()->errorString;
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavplayer_p.h b/src/backends/avplayer/qavplayer_p.h
new file mode 100644
index 0000000..85cd3be
--- /dev/null
+++ b/src/backends/avplayer/qavplayer_p.h
@@ -0,0 +1,121 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVPLAYER_H
+#define QAVPLAYER_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include <private/qavplayerdefs_p.h>
+#include <QMediaPlayer>
+#include <QUrl>
+#include <QScopedPointer>
+#include <QObject>
+
+QT_BEGIN_NAMESPACE
+
+class QAVPlayerPrivate;
+class QAbstractVideoSurface;
+class Q_AVPLAYER_EXPORT QAVPlayer : public QObject
+{
+    Q_OBJECT
+public:
+    QAVPlayer(QObject *parent = nullptr);
+    ~QAVPlayer();
+
+    void setSource(const QUrl &url);
+    QUrl source() const;
+
+    bool isAudioAvailable() const;
+    bool isVideoAvailable() const;
+
+    void setVideoSurface(QAbstractVideoSurface *surface);
+
+    QMediaPlayer::State state() const;
+    QMediaPlayer::MediaStatus mediaStatus() const;
+    qint64 duration() const;
+    qint64 position() const;
+    int volume() const;
+    bool isMuted() const;
+    qreal speed() const;
+
+    bool isSeekable() const;
+    QMediaPlayer::Error error() const;
+    QString errorString() const;
+
+public Q_SLOTS:
+    void play();
+    void pause();
+    void stop();
+    void seek(qint64 position);
+    void setVolume(int volume);
+    void setMuted(bool muted);
+    void setSpeed(qreal rate);
+
+Q_SIGNALS:
+    void sourceChanged(const QUrl &url);
+    void stateChanged(QMediaPlayer::State newState);
+    void mediaStatusChanged(QMediaPlayer::MediaStatus status);
+    void errorOccurred(QMediaPlayer::Error, const QString &str);
+    void durationChanged(qint64 duration);
+    void seekableChanged(bool seekable);
+    void volumeChanged(int volume);
+    void mutedChanged(bool muted);
+    void speedChanged(qreal rate);
+
+protected:
+    QScopedPointer<QAVPlayerPrivate> d_ptr;
+
+private:
+    Q_DISABLE_COPY(QAVPlayer)
+    Q_DECLARE_PRIVATE(QAVPlayer)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavplayerdefs_p.h b/src/backends/avplayer/qavplayerdefs_p.h
new file mode 100644
index 0000000..f5a0e25
--- /dev/null
+++ b/src/backends/avplayer/qavplayerdefs_p.h
@@ -0,0 +1,66 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#ifndef QAVPLAYERDEFS_P_H
+#define QAVPLAYERDEFS_P_H
+
+#include <QtCore/qglobal.h>
+
+#ifndef QT_STATIC
+#    if defined(QT_BUILD_MULTIMEDIAAVPLAYER_LIB)
+#        define Q_AVPLAYER_EXPORT Q_DECL_EXPORT
+#    else
+#        define Q_AVPLAYER_EXPORT Q_DECL_IMPORT
+#    endif
+#else
+#    define Q_AVPLAYER_EXPORT
+#endif
+
+#endif
diff --git a/src/backends/avplayer/qavvideocodec.cpp b/src/backends/avplayer/qavvideocodec.cpp
new file mode 100644
index 0000000..3fdcfc2
--- /dev/null
+++ b/src/backends/avplayer/qavvideocodec.cpp
@@ -0,0 +1,147 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavvideocodec_p.h"
+#include "qavhwdevice_p.h"
+#include "qavcodec_p_p.h"
+#include "qavpacket_p.h"
+#include "qavframe_p.h"
+#include "qavvideoframe_p.h"
+#include <QtMultimedia/private/qtmultimediaglobal_p.h>
+#include <QDebug>
+
+extern "C" {
+#include <libavutil/pixdesc.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+class QAVVideoCodecPrivate : public QAVCodecPrivate
+{
+public:
+    QScopedPointer<QAVHWDevice> hw_device;
+    QAbstractVideoSurface *videoSurface = nullptr;
+};
+
+QAVVideoCodec::QAVVideoCodec(QObject *parent)
+    : QAVCodec(*new QAVVideoCodecPrivate, parent)
+{
+}
+
+QAVVideoCodec::QAVVideoCodec(AVCodec *c, QObject *parent)
+    : QAVVideoCodec(parent)
+{
+    d_ptr->codec = c;
+}
+
+void QAVVideoCodec::setDevice(QAVHWDevice *d)
+{
+    d_func()->hw_device.reset(d);
+}
+
+QAVHWDevice *QAVVideoCodec::device() const
+{
+    return d_func()->hw_device.data();
+}
+
+static AVPixelFormat negotiate_pixel_format(AVCodecContext *c, const AVPixelFormat *f)
+{
+    auto d = reinterpret_cast<QAVVideoCodecPrivate *>(c->opaque);
+
+    QList<AVPixelFormat> supported;
+    QList<AVPixelFormat> unsupported;
+    for (int i = 0; f[i] != AV_PIX_FMT_NONE; ++i) {
+        auto format = QAVVideoFrame::pixelFormat(f[i]);
+        if (format == QVideoFrame::Format_Invalid) {
+            unsupported.append(f[i]);
+            continue;
+        }
+        supported.append(f[i]);
+    }
+
+    qDebug() << "Available pixel formats:";
+    for (auto a : supported) {
+        auto dsc = av_pix_fmt_desc_get(a);
+        qDebug() << "  " << dsc->name << ": AVPixelFormat(" << a << ") =>" << QAVVideoFrame::pixelFormat(a);
+    }
+
+    for (auto a : unsupported) {
+        auto dsc = av_pix_fmt_desc_get(a);
+        qDebug() << "  " << dsc->name << ": AVPixelFormat(" << a << ")";
+    }
+
+    if (d->hw_device) {
+        auto dsc = av_pix_fmt_desc_get(d->hw_device->format());
+        if (d->hw_device->supportsVideoSurface(d->videoSurface)) {
+            qDebug() << "Using hardware decoding in" << dsc->name;
+            return d->hw_device->format();
+        } else {
+            qWarning() << "The video surface does not support hardware device:" << dsc->name;
+        }
+
+        d->hw_device.reset();
+    }
+
+    for (auto sf : d->videoSurface->supportedPixelFormats(QAbstractVideoBuffer::NoHandle)) {
+        auto pf = QAVVideoFrame::pixelFormat(sf);
+        if (supported.contains(pf)) {
+            qDebug() << "Using software decoding in" << sf;
+            return pf;
+        }
+    }
+
+    qDebug() << "None of the surface's pixel format supported:";
+    for (auto a : d->videoSurface->supportedPixelFormats(QAbstractVideoBuffer::NoHandle))
+        qDebug() << "  " << a;
+
+    return !supported.isEmpty() ? supported[0] : AV_PIX_FMT_NONE;
+}
+
+void QAVVideoCodec::setVideoSurface(QAbstractVideoSurface *surface)
+{
+    Q_D(QAVVideoCodec);
+    if (!surface)
+        return;
+
+    d->videoSurface = surface;
+    d->avctx->opaque = d;
+    d->avctx->get_format = negotiate_pixel_format;
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavvideocodec_p.h b/src/backends/avplayer/qavvideocodec_p.h
new file mode 100644
index 0000000..03f4e96
--- /dev/null
+++ b/src/backends/avplayer/qavvideocodec_p.h
@@ -0,0 +1,79 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVVIDEOCODEC_P_H
+#define QAVVIDEOCODEC_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavcodec_p.h"
+#include "qavvideoframe_p.h"
+
+QT_BEGIN_NAMESPACE
+
+class QAVVideoCodecPrivate;
+class QAbstractVideoSurface;
+class QAVHWDevice;
+class Q_AVPLAYER_EXPORT QAVVideoCodec : public QAVCodec
+{
+public:
+    QAVVideoCodec(QObject *parent = nullptr);
+    QAVVideoCodec(AVCodec *c, QObject *parent = nullptr);
+
+    void setDevice(QAVHWDevice *d);
+    QAVHWDevice *device() const;
+    void setVideoSurface(QAbstractVideoSurface *surface);
+
+private:
+    Q_DISABLE_COPY(QAVVideoCodec)
+    Q_DECLARE_PRIVATE(QAVVideoCodec)
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/avplayer/qavvideoframe.cpp b/src/backends/avplayer/qavvideoframe.cpp
new file mode 100644
index 0000000..5779f1a
--- /dev/null
+++ b/src/backends/avplayer/qavvideoframe.cpp
@@ -0,0 +1,119 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qavvideoframe_p.h"
+#include "qavplanarvideobuffer_cpu_p.h"
+#include "qavframe_p_p.h"
+#include "qavvideocodec_p.h"
+#include "qavhwdevice_p.h"
+#include <QVideoFrame>
+#include <QDebug>
+
+QT_BEGIN_NAMESPACE
+
+QAVVideoFrame::QAVVideoFrame(QObject *parent)
+    : QAVFrame(parent)
+{
+}
+
+const QAVVideoCodec *QAVVideoFrame::codec() const
+{
+    return reinterpret_cast<const QAVVideoCodec *>(d_func()->codec);
+}
+
+QAVVideoFrame::QAVVideoFrame(const QAVFrame &other, QObject *parent)
+    : QAVVideoFrame(parent)
+{
+    operator=(other);
+}
+
+QAVVideoFrame &QAVVideoFrame::operator=(const QAVFrame &other)
+{
+    QAVFrame::operator=(other);
+    return *this;
+}
+
+QVideoFrame::PixelFormat QAVVideoFrame::pixelFormat(AVPixelFormat from)
+{
+    switch (from) {
+    case AV_PIX_FMT_YUV420P:
+        return QVideoFrame::Format_YUV420P;
+    case AV_PIX_FMT_NV12:
+        return QVideoFrame::Format_NV12;
+    case AV_PIX_FMT_BGRA:
+        return QVideoFrame::Format_BGRA32;
+    case AV_PIX_FMT_ARGB:
+        return QVideoFrame::Format_ARGB32;
+    default:
+        return QVideoFrame::Format_Invalid;
+    }
+}
+
+AVPixelFormat QAVVideoFrame::pixelFormat(QVideoFrame::PixelFormat from)
+{
+    switch (from) {
+    case QVideoFrame::Format_YUV420P:
+        return AV_PIX_FMT_YUV420P;
+    case QVideoFrame::Format_NV12:
+        return AV_PIX_FMT_NV12;
+    default:
+        return AV_PIX_FMT_NONE;
+    }
+}
+
+QSize QAVVideoFrame::size() const
+{
+    Q_D(const QAVFrame);
+    return {d->frame->width, d->frame->height};
+}
+
+QAVVideoFrame::operator QVideoFrame() const
+{
+    Q_D(const QAVFrame);
+    if (!codec())
+        return {};
+
+    if (codec()->device())
+        return codec()->device()->decode(*this);
+
+    auto format = pixelFormat(AVPixelFormat(d->frame->format));
+    return {new QAVPlanarVideoBuffer_CPU(*this), size(), format};
+}
+
+QT_END_NAMESPACE
diff --git a/src/backends/avplayer/qavvideoframe_p.h b/src/backends/avplayer/qavvideoframe_p.h
new file mode 100644
index 0000000..485a3f1
--- /dev/null
+++ b/src/backends/avplayer/qavvideoframe_p.h
@@ -0,0 +1,85 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QAVFVIDEORAME_H
+#define QAVFVIDEORAME_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API. It exists purely as an
+// implementation detail. This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qavframe_p.h"
+#include <private/qavplayerdefs_p.h>
+#include <QVideoFrame>
+
+extern "C" {
+#include <libavformat/avformat.h>
+}
+
+QT_BEGIN_NAMESPACE
+
+class QAVVideoFramePrivate;
+class QAVVideoCodec;
+class Q_AVPLAYER_EXPORT QAVVideoFrame : public QAVFrame
+{
+public:
+    QAVVideoFrame(QObject *parent = nullptr);
+    QAVVideoFrame(const QAVFrame &other, QObject *parent = nullptr);
+
+    QAVVideoFrame &operator=(const QAVFrame &other);
+
+    const QAVVideoCodec *codec() const;
+    QSize size() const;
+
+    operator QVideoFrame() const;
+
+    static QVideoFrame::PixelFormat pixelFormat(AVPixelFormat from);
+    static AVPixelFormat pixelFormat(QVideoFrame::PixelFormat from);
+};
+
+QT_END_NAMESPACE
+
+#endif
diff --git a/src/backends/backends.pro b/src/backends/backends.pro
new file mode 100644
index 0000000..5de11d2
--- /dev/null
+++ b/src/backends/backends.pro
@@ -0,0 +1,6 @@
+TEMPLATE = subdirs
+
+include($$OUT_PWD/multimedia/qtmultimedia-config.pri)
+QT_FOR_CONFIG += multimedia-private
+
+qtConfig(ffmpeg): SUBDIRS += avplayer
diff --git a/src/multimedia/configure.json b/src/multimedia/configure.json
index d50f8c0..c787565 100644
--- a/src/multimedia/configure.json
+++ b/src/multimedia/configure.json
@@ -18,6 +18,41 @@
     },
 
     "libraries": {
+        "ffmpeg": {
+            "label": "FFmpeg",
+            "export": "ffmpeg",
+            "test":  {
+                "include": "libavcodec/avcodec.h"
+            },
+            "sources": [
+                { "type": "pkgConfig",
+                  "args": "libavcodec libavformat libavutil libswresample" },
+                { "libs": "-lavcodec -lavformat -lswscale -lavutil -lswresample" },
+                { "libs": "", "condition": "config.android" }
+            ]
+        },
+        "va_x11": {
+            "label": "va_x11",
+            "export": "va_x11",
+            "test":  {
+                "include": "va/va_x11.h"
+            },
+            "sources": [
+                { "type": "pkgConfig",
+                  "args": "libva-x11" }
+            ]
+        },
+        "va_drm": {
+            "label": "va_drm",
+            "export": "va_drm",
+            "test":  {
+                "include": "va/va_drm.h"
+            },
+            "sources": [
+                { "type": "pkgConfig",
+                  "args": "libva-drm" }
+            ]
+        },
         "alsa": {
             "label": "ALSA",
             "test": "alsa",
@@ -174,6 +209,21 @@
     },
 
     "features": {
+        "ffmpeg": {
+            "label": "FFmpeg",
+            "condition": "libs.ffmpeg",
+            "output": [ "privateFeature" ]
+        },
+        "va_x11": {
+            "label": "va_x11",
+            "condition": "libs.va_x11",
+            "output": [ "privateFeature" ]
+        },
+        "va_drm": {
+            "label": "va_drm",
+            "condition": "libs.va_drm",
+            "output": [ "privateFeature" ]
+        },
         "alsa": {
             "label": "ALSA",
             "condition": "config.unix && !config.qnx && libs.alsa",
@@ -285,6 +335,9 @@
             "section": "Qt Multimedia",
             "entries": [
                 "alsa",
+                "ffmpeg",
+                "va_x11",
+                "va_drm",
                 "gstreamer_1_0",
                 "gstreamer_0_10",
                 "linux_v4l",
diff --git a/src/src.pro b/src/src.pro
index 1dc1015..5b6ebd5 100644
--- a/src/src.pro
+++ b/src/src.pro
@@ -1,6 +1,6 @@
 TEMPLATE = subdirs
 
-SUBDIRS += multimedia
+SUBDIRS += multimedia backends
 
 include($$OUT_PWD/multimedia/qtmultimedia-config.pri)
 QT_FOR_CONFIG += multimedia-private
diff --git a/sync.profile b/sync.profile
index 2ac22b5..c0cdc0b 100644
--- a/sync.profile
+++ b/sync.profile
@@ -3,6 +3,7 @@
     "QtMultimediaWidgets" => "$basedir/src/multimediawidgets",
     "QtMultimediaQuick" => "$basedir/src/qtmultimediaquicktools",
     "QtMultimediaGstTools" => "$basedir/src/gsttools",
+    "QtMultimediaAVPlayer" => "$basedir/src/backends/avplayer",
 );
 
 %moduleheaders = ( # restrict the module headers to those found in relative path
diff --git a/tests/auto/integration/qavdemuxer/qavdemuxer.pro b/tests/auto/integration/qavdemuxer/qavdemuxer.pro
new file mode 100644
index 0000000..e47d46c
--- /dev/null
+++ b/tests/auto/integration/qavdemuxer/qavdemuxer.pro
@@ -0,0 +1,9 @@
+TARGET = tst_qavdemuxer
+
+QT += multimedia-private testlib multimediaavplayer-private
+
+CONFIG += testcase
+
+SOURCES += \
+    tst_qavdemuxer.cpp
+
diff --git a/tests/auto/integration/qavdemuxer/tst_qavdemuxer.cpp b/tests/auto/integration/qavdemuxer/tst_qavdemuxer.cpp
new file mode 100644
index 0000000..6fb63c6
--- /dev/null
+++ b/tests/auto/integration/qavdemuxer/tst_qavdemuxer.cpp
@@ -0,0 +1,229 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "private/qavdemuxer_p.h"
+#include "private/qavaudioframe_p.h"
+#include "private/qavvideoframe_p.h"
+#include "private/qavvideocodec_p.h"
+#include "private/qavaudiocodec_p.h"
+
+#include <QtMultimedia/private/qtmultimedia-config_p.h>
+#include <QDebug>
+#include <QtTest/QtTest>
+
+QT_USE_NAMESPACE
+
+class tst_QAVDemuxer : public QObject
+{
+    Q_OBJECT
+private slots:
+    void construction();
+    void loadIncorrect();
+    void loadAudio();
+    void loadVideo();
+};
+
+void tst_QAVDemuxer::construction()
+{
+    QAVDemuxer d;
+    QVERIFY(d.videoStream() < 0);
+    QVERIFY(d.audioStream() < 0);
+    QVERIFY(d.subtitleStream() < 0);
+    QCOMPARE(d.videoCodec(), nullptr);
+    QCOMPARE(d.audioCodec(), nullptr);
+    QCOMPARE(d.duration(), 0);
+    QCOMPARE(d.seekable(), false);
+    QCOMPARE(d.eof(), false);
+    QVERIFY(!d.read());
+    QVERIFY(d.seek(0) < 0);
+
+    QAVPacket p;
+    QVERIFY(!p);
+    QCOMPARE(p.duration(), 0);
+    QCOMPARE(p.bytes(), 0);
+    QVERIFY(p.streamIndex() < 0);
+    QVERIFY(!p.decode());
+
+    QAVFrame f;
+    QVERIFY(!f);
+    QCOMPARE(f.pts(), -1);
+
+    QAVAudioFrame af;
+    QVERIFY(!af);
+    QCOMPARE(af.pts(), -1);
+
+    QAVVideoFrame vf;
+    QVERIFY(!vf);
+    QVideoFrame vvf = vf;
+    QVERIFY(!vvf.isValid());
+}
+
+void tst_QAVDemuxer::loadIncorrect()
+{
+    QAVDemuxer d;
+    QVERIFY(d.load(QUrl("unknown.mp4")) < 0);
+    QVERIFY(d.videoStream() < 0);
+    QVERIFY(d.audioStream() < 0);
+    QVERIFY(d.subtitleStream() < 0);
+    QVERIFY(!d.read());
+    QVERIFY(d.seek(0) < 0);
+}
+
+void tst_QAVDemuxer::loadAudio()
+{
+    QAVDemuxer d;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/test.wav"));
+
+    QVERIFY(d.load(QUrl::fromLocalFile(file.absoluteFilePath())) >= 0);
+    QVERIFY(d.videoStream() < 0);
+    QVERIFY(d.audioStream() >= 0);
+    QVERIFY(d.subtitleStream() < 0);
+    QVERIFY(d.duration() > 0);
+    QCOMPARE(d.seekable(), true);
+    QCOMPARE(d.eof(), false);
+
+    QAVPacket p;
+    QAVPacket p2;
+    QAVFrame f2;
+    while ((p = d.read())) {
+        QVERIFY(p);
+        QVERIFY(p.packet());
+        QVERIFY(p.duration() > 0);
+        QVERIFY(p.bytes() > 0);
+        QCOMPARE(p.streamIndex(), d.audioStream());
+
+        p2 = p;
+        QVERIFY(p2);
+        QCOMPARE(p2.duration(), p.duration());
+        QCOMPARE(p2.bytes(), p.bytes());
+        QCOMPARE(p2.streamIndex(), p.streamIndex());
+
+        QAVPacket p3 = p2;
+        QVERIFY(p2);
+        QCOMPARE(p2.duration(), p.duration());
+        QCOMPARE(p2.bytes(), p.bytes());
+        QCOMPARE(p2.streamIndex(), p.streamIndex());
+
+        auto f = p.decode();
+        QVERIFY(f);
+        QVERIFY(f.frame());
+        QVERIFY(f.pts() >= 0);
+
+        f2 = f;
+        QVERIFY(f2);
+        QVERIFY(f2.frame());
+        QCOMPARE(f2.pts(), f.pts());
+
+        QAVFrame f3 = f2;
+        QVERIFY(f3);
+        QVERIFY(f3.frame());
+        QCOMPARE(f3.pts(), f.pts());
+
+        QAVAudioFrame af = f;
+        QVERIFY(af);
+        QVERIFY(af.frame());
+        QCOMPARE(af.pts(), f.pts());
+        QVERIFY(af.codec());
+
+        auto format = af.codec()->audioFormat();
+        QVERIFY(format.isValid());
+        auto data = af.data(format);
+        QVERIFY(!data.isEmpty());
+
+        QCOMPARE(d.eof(), false);
+    }
+
+    QVERIFY(p2);
+    QVERIFY(p2.packet());
+    QVERIFY(p2.duration() > 0);
+    QVERIFY(p2.bytes() > 0);
+    QCOMPARE(p2.streamIndex(), d.audioStream());
+
+    QVERIFY(f2);
+    QVERIFY(f2.frame());
+    QVERIFY(f2.pts() > 0);
+
+    QCOMPARE(d.eof(), true);
+    QVERIFY(d.seek(0) >= 0);
+}
+
+void tst_QAVDemuxer::loadVideo()
+{
+    QAVDemuxer d;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/colors.mp4"));
+
+    QVERIFY(d.load(QUrl::fromLocalFile(file.absoluteFilePath())) >= 0);
+    QVERIFY(d.videoStream() >= 0);
+    QVERIFY(d.audioStream() >= 0);
+    QVERIFY(d.subtitleStream() < 0);
+    QVERIFY(d.duration() > 0);
+    QCOMPARE(d.seekable(), true);
+    QCOMPARE(d.eof(), false);
+
+    auto p = d.read();
+    QVERIFY(p);
+    QVERIFY(p.packet());
+    QVERIFY(p.duration() > 0);
+    QVERIFY(p.bytes() > 0);
+    QVERIFY(p.streamIndex() >= 0);
+
+    auto f = p.decode();
+    QVERIFY(f);
+    QVERIFY(f.frame());
+    QVERIFY(f.pts() >= 0);
+    QCOMPARE(d.eof(), false);
+
+    QVERIFY(d.seek(0) >= 0);
+    while ((p = d.read())) {
+        QCOMPARE(d.eof(), false);
+        if (p.streamIndex() == d.videoStream()) {
+            auto f = p.decode();
+            QVERIFY(f);
+            QVERIFY(f.frame());
+            QVERIFY(f.pts() >= 0);
+
+            QAVVideoFrame vf = f;
+            QVERIFY(vf);
+            QVERIFY(vf.frame());
+            QCOMPARE(vf.pts(), f.pts());
+            QVERIFY(vf.size().isValid());
+
+            QVideoFrame vvf = vf;
+            QVERIFY(vvf.isValid());
+            QCOMPARE(vvf.size(), vf.size());
+            QVERIFY(vvf.pixelFormat() != QVideoFrame::Format_Invalid);
+        }
+    }
+
+    QCOMPARE(d.eof(), true);
+}
+
+QTEST_MAIN(tst_QAVDemuxer)
+#include "tst_qavdemuxer.moc"
diff --git a/tests/auto/integration/qavplayer/qavplayer.pro b/tests/auto/integration/qavplayer/qavplayer.pro
new file mode 100644
index 0000000..0bcefab
--- /dev/null
+++ b/tests/auto/integration/qavplayer/qavplayer.pro
@@ -0,0 +1,8 @@
+TARGET = tst_qavplayer
+
+QT += multimedia-private testlib multimediaavplayer-private
+
+CONFIG += testcase
+
+SOURCES += \
+    tst_qavplayer.cpp
diff --git a/tests/auto/integration/qavplayer/tst_qavplayer.cpp b/tests/auto/integration/qavplayer/tst_qavplayer.cpp
new file mode 100644
index 0000000..face152
--- /dev/null
+++ b/tests/auto/integration/qavplayer/tst_qavplayer.cpp
@@ -0,0 +1,650 @@
+/****************************************************************************
+**
+** Copyright (C) 2020 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:GPL-EXCEPT$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 3 as published by the Free Software
+** Foundation with exceptions as appearing in the file LICENSE.GPL3-EXCEPT
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "private/qavplayer_p.h"
+#include <qabstractvideosurface.h>
+#include <QtMultimedia/private/qtmultimedia-config_p.h>
+#include <QDebug>
+#include <QtTest/QtTest>
+
+QT_USE_NAMESPACE
+
+class tst_QAVPlayer : public QObject
+{
+    Q_OBJECT
+private slots:
+    void construction();
+    void sourceChanged();
+    void volumeChanged();
+    void mutedChanged();
+    void speedChanged();
+    void quitAudio();
+    void playIncorrectSource();
+    void playAudio();
+    void pauseAudio();
+    void volumeAudio();
+    void stopAudio();
+    void seekAudio();
+    void speedAudio();
+    void playVideo();
+    void pauseVideo();
+    void seekVideo();
+    void speedVideo();
+    void surfaceVideo();
+    void surfaceVideoUnsupported();
+};
+
+void tst_QAVPlayer::construction()
+{
+    QAVPlayer p;
+    QVERIFY(p.source().isEmpty());
+    QVERIFY(!p.isAudioAvailable());
+    QVERIFY(!p.isVideoAvailable());
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::NoMedia);
+    QCOMPARE(p.duration(), 0);
+    QCOMPARE(p.position(), 0);
+    QCOMPARE(p.volume(), 100);
+    QVERIFY(!p.isMuted());
+    QCOMPARE(p.speed(), 1.0);
+    QVERIFY(!p.isSeekable());
+    QCOMPARE(p.error(), QMediaPlayer::NoError);
+    QVERIFY(p.errorString().isEmpty());
+}
+
+void tst_QAVPlayer::sourceChanged()
+{
+    QAVPlayer p;
+    QSignalSpy spy(&p, &QAVPlayer::sourceChanged);
+    p.setSource(QUrl(QLatin1String("unknown.mp4")));
+    QCOMPARE(spy.count(), 1);
+    p.setSource(QUrl(QLatin1String("unknown.mp4")));
+    QCOMPARE(spy.count(), 1);
+}
+
+void tst_QAVPlayer::volumeChanged()
+{
+    QAVPlayer p;
+    QSignalSpy spy(&p, &QAVPlayer::volumeChanged);
+    QCOMPARE(p.volume(), 100);
+    p.setVolume(10);
+    QCOMPARE(spy.count(), 1);
+    QCOMPARE(p.volume(), 10);
+    p.setVolume(0);
+    QCOMPARE(spy.count(), 2);
+    QCOMPARE(p.volume(), 0);
+    p.setVolume(-10);
+    QCOMPARE(spy.count(), 2);
+    QCOMPARE(p.volume(), 0);
+    p.setVolume(200);
+    QCOMPARE(spy.count(), 2);
+    QCOMPARE(p.volume(), 0);
+    p.setVolume(100);
+    QCOMPARE(spy.count(), 3);
+    QCOMPARE(p.volume(), 100);
+}
+
+void tst_QAVPlayer::mutedChanged()
+{
+    QAVPlayer p;
+    QSignalSpy spy(&p, &QAVPlayer::mutedChanged);
+    QVERIFY(!p.isMuted());
+    p.setMuted(true);
+    QCOMPARE(spy.count(), 1);
+    QVERIFY(p.isMuted());
+}
+
+void tst_QAVPlayer::speedChanged()
+{
+    QAVPlayer p;
+    QSignalSpy spy(&p, &QAVPlayer::speedChanged);
+    QCOMPARE(p.speed(), 1.0);
+    p.setSpeed(0);
+    QCOMPARE(spy.count(), 1);
+    QCOMPARE(p.speed(), 0.0);
+    p.setSpeed(2);
+    QCOMPARE(spy.count(), 2);
+    QCOMPARE(p.speed(), 2.0);
+}
+
+void tst_QAVPlayer::quitAudio()
+{
+    QAVPlayer p;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/test.wav"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+}
+
+void tst_QAVPlayer::playIncorrectSource()
+{
+    QAVPlayer p;
+    QSignalSpy spy(&p, &QAVPlayer::stateChanged);
+
+    p.play();
+
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::NoMedia);
+    QVERIFY(!p.isAudioAvailable());
+    QVERIFY(!p.isVideoAvailable());
+    QCOMPARE(spy.count(), 0);
+
+    p.setSource(QUrl(QLatin1String("unknown")));
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::InvalidMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.error(), QMediaPlayer::ResourceError);
+    QVERIFY(!p.errorString().isEmpty());
+
+    p.play();
+
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::InvalidMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.error(), QMediaPlayer::ResourceError);
+    QVERIFY(!p.errorString().isEmpty());
+    QVERIFY(!p.isAudioAvailable());
+    QVERIFY(!p.isVideoAvailable());
+    QCOMPARE(spy.count(), 0);
+
+    p.setSource(QUrl(QLatin1String("unknown")));
+    p.play();
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::InvalidMedia);
+    QCOMPARE(spy.count(), 0);
+}
+
+void tst_QAVPlayer::playAudio()
+{
+    QAVPlayer p;
+    QSignalSpy spyState(&p, &QAVPlayer::stateChanged);
+    QSignalSpy spyMediaStatus(&p, &QAVPlayer::mediaStatusChanged);
+    QSignalSpy spyDuration(&p, &QAVPlayer::durationChanged);
+
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::NoMedia);
+    QVERIFY(!p.isAudioAvailable());
+    QVERIFY(!p.isVideoAvailable());
+    QVERIFY(!p.isSeekable());
+    QCOMPARE(spyState.count(), 0);
+    QCOMPARE(spyMediaStatus.count(), 0);
+    QCOMPARE(spyDuration.count(), 0);
+
+    p.setSource({});
+
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::NoMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/test.wav"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(spyState.count(), 0);
+    QCOMPARE(spyMediaStatus.count(), 2); // NoMedia -> Loading -> Loaded
+    QCOMPARE(spyDuration.count(), 1);
+    QCOMPARE(p.duration(), 999);
+    QCOMPARE(p.position(), 0);
+    QCOMPARE(p.error(), QMediaPlayer::NoError);
+    QVERIFY(p.errorString().isEmpty());
+    QVERIFY(p.isAudioAvailable());
+    QVERIFY(!p.isVideoAvailable());
+    QVERIFY(p.isSeekable());
+
+    p.play();
+
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QCOMPARE(spyState.count(), 1); // Stopped -> Playing
+    QCOMPARE(spyMediaStatus.count(), 2);
+
+    QTRY_VERIFY(p.position() != 0);
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.position(), p.duration());
+
+    spyState.clear();
+    spyMediaStatus.clear();
+    spyDuration.clear();
+
+    p.play();
+
+    QTRY_COMPARE(p.state(), QMediaPlayer::PlayingState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QCOMPARE(spyState.count(), 1); // Stopped -> Playing
+    QCOMPARE(spyMediaStatus.count(), 1); // EndOfMedia -> LoadedMedia
+    QCOMPARE(spyDuration.count(), 0);
+    QCOMPARE(p.duration(), 999);
+    QCOMPARE(p.error(), QMediaPlayer::NoError);
+    QVERIFY(p.errorString().isEmpty());
+
+    QTRY_VERIFY(p.position() != 0);
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.position(), p.duration());
+
+    p.setSource({});
+
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::NoMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+
+    p.play();
+
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::NoMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+}
+
+void tst_QAVPlayer::pauseAudio()
+{
+    QAVPlayer p;
+    QSignalSpy spyState(&p, &QAVPlayer::stateChanged);
+    QSignalSpy spyMediaStatus(&p, &QAVPlayer::mediaStatusChanged);
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/test.wav"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    p.play();
+
+    QTest::qWait(50);
+    p.pause();
+
+    QCOMPARE(p.state(), QMediaPlayer::PausedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QCOMPARE(spyState.count(), 2); // Stopped -> Playing -> Paused
+    QCOMPARE(spyMediaStatus.count(), 2); // NoMedia -> Loading -> Loaded
+
+    p.play();
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+}
+
+void tst_QAVPlayer::volumeAudio()
+{
+    QAVPlayer p;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/test.wav"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    p.setVolume(0);
+    p.play();
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+    QCOMPARE(p.volume(), 0);
+
+    p.setVolume(50);
+    p.play();
+
+    QTest::qWait(500);
+    p.setVolume(100);
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+    QCOMPARE(p.volume(), 100);
+}
+
+void tst_QAVPlayer::stopAudio()
+{
+    QAVPlayer p;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/test.wav"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+    p.play();
+
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QTRY_VERIFY(p.position() != 0);
+
+    p.stop();
+
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QVERIFY(p.position() != 0);
+    QVERIFY(p.duration() != 0);
+
+    p.play();
+
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QTRY_COMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+}
+
+void tst_QAVPlayer::seekAudio()
+{
+    QAVPlayer p;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/test.wav"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    p.seek(500);
+    QCOMPARE(p.position(), 500);
+    p.play();
+
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QVERIFY(p.position() >= 500);
+    QTRY_COMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.position(), p.duration());
+
+    p.seek(100);
+    QCOMPARE(p.position(), 100);
+    p.play();
+
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QTRY_COMPARE(p.position(), p.duration());
+
+    p.seek(100000);
+    p.play();
+
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QTRY_COMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+    QCOMPARE(p.position(), p.duration());
+
+    p.seek(200);
+    p.play();
+    QTRY_VERIFY(p.position() > 200);
+
+    p.seek(100);
+    QTRY_VERIFY(p.position() < 200);
+
+    p.seek(p.duration());
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+}
+
+void tst_QAVPlayer::speedAudio()
+{
+    QAVPlayer p;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/test.wav"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    p.setSpeed(0.5);
+    p.play();
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QCOMPARE(p.speed(), 0.5);
+    p.setSpeed(2.0);
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+}
+
+void tst_QAVPlayer::playVideo()
+{
+    QAVPlayer p;
+    QSignalSpy spyState(&p, &QAVPlayer::stateChanged);
+    QSignalSpy spyMediaStatus(&p, &QAVPlayer::mediaStatusChanged);
+    QSignalSpy spyDuration(&p, &QAVPlayer::durationChanged);
+
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::NoMedia);
+    QVERIFY(!p.isAudioAvailable());
+    QVERIFY(!p.isVideoAvailable());
+    QVERIFY(!p.isSeekable());
+    QCOMPARE(spyState.count(), 0);
+    QCOMPARE(spyMediaStatus.count(), 0);
+    QCOMPARE(spyDuration.count(), 0);
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/colors.mp4"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(spyState.count(), 0);
+    QCOMPARE(spyMediaStatus.count(), 2); // NoMedia -> Loading -> Loaded
+    QCOMPARE(spyDuration.count(), 1);
+    QCOMPARE(p.duration(), 15019);
+    QCOMPARE(p.error(), QMediaPlayer::NoError);
+    QVERIFY(p.errorString().isEmpty());
+    QVERIFY(p.isAudioAvailable());
+    QVERIFY(p.isVideoAvailable());
+    QVERIFY(p.isSeekable());
+    QCOMPARE(p.position(), 0);
+
+    p.play();
+
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QCOMPARE(spyState.count(), 1); // Stopped -> Playing
+
+    QTRY_VERIFY(p.position() != 0);
+}
+
+void tst_QAVPlayer::pauseVideo()
+{
+    QAVPlayer p;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/colors.mp4"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+
+    p.play();
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+
+    QTest::qWait(50);
+    p.pause();
+    QCOMPARE(p.state(), QMediaPlayer::PausedState);
+}
+
+void tst_QAVPlayer::seekVideo()
+{
+    QAVPlayer p;
+    QSignalSpy spyState(&p, &QAVPlayer::stateChanged);
+    QSignalSpy spyMediaStatus(&p, &QAVPlayer::mediaStatusChanged);
+    QSignalSpy spyDuration(&p, &QAVPlayer::durationChanged);
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/colors.mp4"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    p.seek(14500);
+    p.play();
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.position(), p.duration());
+
+    spyState.clear();
+    spyMediaStatus.clear();
+    spyDuration.clear();
+
+    p.play();
+
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QCOMPARE(spyState.count(), 1); // Stopped -> Playing
+    QCOMPARE(spyMediaStatus.count(), 1); // EndOfMedia -> LoadedMedia
+    QCOMPARE(spyDuration.count(), 0);
+    QCOMPARE(p.duration(), 15019);
+    QCOMPARE(p.error(), QMediaPlayer::NoError);
+    QVERIFY(p.errorString().isEmpty());
+
+    QTRY_VERIFY(p.position() < 5000 && p.position() > 1000);
+
+    p.stop();
+
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QVERIFY(p.position() != p.duration());
+
+    spyState.clear();
+    spyMediaStatus.clear();
+    spyDuration.clear();
+
+    p.setSource({});
+
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::NoMedia);
+    QCOMPARE(p.duration(), 0);
+    QCOMPARE(p.position(), 0);
+    QCOMPARE(spyState.count(), 0);
+    QCOMPARE(spyMediaStatus.count(), 1); // EndOfMedia -> NoMedia
+    QCOMPARE(spyDuration.count(), 1);
+
+    spyState.clear();
+    spyMediaStatus.clear();
+    spyDuration.clear();
+
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+    p.play();
+
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QTRY_COMPARE(spyMediaStatus.count(), 2); // NoMedia -> Loading -> Loaded
+    QCOMPARE(spyState.count(), 1); // Stopped -> Playing
+    QCOMPARE(spyDuration.count(), 1);
+
+    p.seek(14500);
+
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+
+    p.play();
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QTRY_VERIFY(p.position() != p.duration());
+
+    QTest::qWait(10);
+    p.stop();
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+
+    p.seek(0);
+
+    QCOMPARE(p.position(), 0);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+
+    p.seek(-1);
+
+    QCOMPARE(p.position(), 0);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+
+    p.seek(5000);
+    p.play();
+
+    QTRY_VERIFY(p.position() > 5000);
+
+    p.seek(13000);
+    QTRY_VERIFY(p.position() > 13000);
+
+    p.seek(2000);
+    QCOMPARE(p.position(), 2000);
+
+    QTest::qWait(50);
+    p.pause();
+    p.seek(14500);
+    QCOMPARE(p.state(), QMediaPlayer::PausedState);
+
+    p.play();
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::EndOfMedia);
+    p.play();
+}
+
+void tst_QAVPlayer::speedVideo()
+{
+    QAVPlayer p;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/colors.mp4"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    p.setSpeed(5);
+    p.play();
+
+    QTRY_COMPARE_WITH_TIMEOUT(p.mediaStatus(), QMediaPlayer::EndOfMedia, 10000);
+
+    p.setSpeed(0.5);
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+    QCOMPARE(p.speed(), 0.5);
+
+    p.play();
+
+    QTest::qWait(100);
+    p.setSpeed(5);
+    p.pause();
+    QCOMPARE(p.state(), QMediaPlayer::PausedState);
+
+    p.play();
+}
+
+class Surface : public QAbstractVideoSurface
+{
+public:
+    Surface(const QList<QVideoFrame::PixelFormat> &f): formats(f) {}
+    QList<QVideoFrame::PixelFormat> supportedPixelFormats(
+        QAbstractVideoBuffer::HandleType) const override
+    {
+        return formats;
+    }
+
+    bool present(const QVideoFrame &f) override
+    {
+        if (f.isValid() && supportedPixelFormats(f.handleType()).contains(f.pixelFormat()))
+            ++frames;
+        return true;
+    }
+
+    int frames = 0;
+    QList<QVideoFrame::PixelFormat> formats;
+};
+
+void tst_QAVPlayer::surfaceVideo()
+{
+    QAVPlayer p;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/colors.mp4"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+
+    Surface s({QVideoFrame::Format_YUV420P});
+    p.setVideoSurface(&s);
+
+    QCOMPARE(p.state(), QMediaPlayer::StoppedState);
+
+    p.play();
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QTRY_VERIFY(s.frames > 0);
+}
+
+void tst_QAVPlayer::surfaceVideoUnsupported()
+{
+    QAVPlayer p;
+
+    QFileInfo file(QLatin1String("../qmediaplayerbackend/testdata/colors.mp4"));
+    p.setSource(QUrl::fromLocalFile(file.absoluteFilePath()));
+    p.play();
+
+    Surface s({QVideoFrame::Format_Invalid});
+    p.setVideoSurface(&s);
+
+    QCOMPARE(p.state(), QMediaPlayer::PlayingState);
+    QTRY_COMPARE(p.mediaStatus(), QMediaPlayer::LoadedMedia);
+    QVERIFY(s.frames == 0);
+}
+
+QTEST_MAIN(tst_QAVPlayer)
+#include "tst_qavplayer.moc"
